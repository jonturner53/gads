<html>
<head>
<title>Trees and Forests</title>
<link type="text/css" rel="stylesheet" href="../../main.css">
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</head>
<body bgcolor=ffffff>
<h1>Trees and Forests<sup>&copy;</sup></h1>
An <i>undirected tree</i> is simply an undirected graph that is connected
and has no cycles. A <i>forest</i> is an undirected graph in which
each connected component is a tree.
A vertex in a tree with just one edge is called a <i>leaf</i>.
In a <i>directed tree</i>, edges are directed outward from a designated
<i>root</i> vertex. If an directed tree contains an edge $(u,v)$,
then $u$ is referred to as the <i>parent</i> of $v$.
The subtree defined by a vertex $u$'s descendants is referred to
as $u$'s subtree.
While trees can be represented using the graph data structures already
defined, it is often convenient to have a data structure that is
designed for the special case of trees and forests.

<a id=forest><h2>Forest</h2></a>
The <code>Forest</code> class defines a collection of directed trees
that partition a common vertex set.
Each vertex has a defined <i>parent</i> and a <i>first child</i>.
Vertices that share a common parent are called 
<i>siblings</i> and are organized into sibling lists.
Each tree is identified by its root.
The class includes the methods listed below.
<ul>
<li>    <code>p(u)</code> returns the parent of vertex <code>u</code>.
<li>    <code>firstChild(u)</code> returns the first child of <code>u</code>.
<li>    <code>nextSibling(u)</code> returns the next sibling of <code>u</code>.
<li>    <code>root(u)</code> returns the root of the tree containg
        <code>u</code>.
<li>    <code>first(u)</code> returns the first vertex in the prefix ordering
        of the vertices within <code>u</code>'s subtree.
<li>    <code>next(u,r=0)</code> returns the next vertex after $u$ in the
        prefix ordering of the vertices within <code>r</code>'s subtree
        (or the entire tree if <code>r</code> is omitted).
<li>    <code>firstLeaf(u)</code> returns the first leaf in the
        prefix ordering of the vertices within <code>u</code>'s subtree.
<li>    <code>nextLeaf(u,r=0)</code> returns the next leaf after $u$ in the
        prefix ordering of the vertices within <code>r</code>'s subtree
        (or the entire tree if <code>r</code> is omitted).
<li>    <code>cut(u)</code> cuts the link between <code>u</code> and its
        parent, making <code>u</code> the root of a separate tree.
<li>    <code>link(u,v)</code> links the tree with root <code>u</code>
        to the tree containing <code>v</code>, making <code>v</code>
        the parent of <code>u</code>; <code>u</code> is added at the
        end of the sibling list that contains <code>v</code>'s children.
<li>    <code>setEquals(other)</code> is similar to <code>equals</code>
        but considers two <code>Forest</code> objects equal if the trees
        define the same vertex sets.
<li>    <code>listEquals(other)</code> is similar to <code>equals</code>
        but considers two <code>Forest</code> objects equal if the trees
        define the same vertex sets and the order of the vertices within
        each tree are identical.
<li>    <code>joinGroups(g1,g2)</code> combines two <i>tree groups</i>,
        into a single group.
<li>    <code>ungroup(t,g)</code> removes tree <code>t</code> from the
        group <code>g</code> containing it.
</ul>
The <code>first</code> and <code>next</code> methods can be used to iterate
through all vertices in the tree. The time required to visit all vertices
is $O(n)$ although individual steps may take more than constant time.
The <code>firstLeaf</code> and <code>nextLeaf</code> methods can be used
to iterate through the leaf vertices in the tree.
The last two methods allow subsets of trees to be grouped together.
Trees in the same group are considered siblings of one another and
each group is identified by the first tree in its sibling list.
<p>
The core of the <i>Javascript</i> implementation is shown below.
<p>
<textarea id="components" rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class Forest extends Top {
    #sibs;    // lists of siblings
    #p;       // #p[u] is parent of u or 0
    #c;       // #c[u] is first child of u or 0

    /** Construct Forest with space for a specified # of nodes.
     *  @param n is the number of nodes in the forest
     *  @param cap is the initial capacity (defaults to n)
     */
    constructor(n=10, capacity=n) {
        super(n);
        this.#sibs= new ListSet(n,capacity);
        this.#p = new Int32Array(capacity+1);
        this.#c = new Int32Array(capacity+1);
        this.steps = 0;
    }

    /** Get the parent of a node.
     *  @param u is a node in the forest
     *  @return the u's parent or 0.
     */
    p(u) { return this.#p[u]; }

    /** Get the first child of a node.
     *  @param u is a node in the forest
     *  @return the u's first child or 0.
     */
    firstChild(u) { return this.#c[u]; }

    /** Get the root of a tree containing a node.
     *  @param u is a node in some tree
     *  @return the tree root
     */
    root(u) {
        while (this.p(u) != 0)  {
            u = this.p(u); this.steps++;
        }
        return u;
    }

    /** Return the first node in the prefix ordering within a subtree. */
    first(u) { return u; }

    /** Return the next descendant of a node in the prefix ordering.
     *  @param u is a tree node
     *  @param root is an ancestor of u; if root is included, iteration
     *  stops at last node in subtree, otherwise, it continues through
     *  all trees in same group as u
     *  @return the next node in the subtree at root following u
     */
    next(u,root=0) {
        if (this.firstChild(u)) return this.firstChild(u);
        do {
            this.steps++;
            if (this.nextSibling(u)) return this.nextSibling(u);
            u = this.p(u);
        } while (u != root);
        return 0;
    }

    /** Return the first leaf descendant of a node */
    firstLeaf(u) {
        while (this.firstChild(u)) {
            u = this.firstChild(u); this.steps++;
        }
        return u;
    }

    /** Return the next leaf in a tree or subtree.
     *  @param u is a leaf node
     *  @param root is an ancestor of u
     *  @return the next leaf following u in the prefix ordering,
     *  within the subtree defined by root
     */
    nextLeaf(u,root=0) {
        while (u != root) {
            this.steps++;
            if (this.nextSibling(u))
                return this.firstLeaf(this.nextSibling(u));
            u = this.p(u);
        }
        return 0;
    }
    
    /** Link one tree to another.
     *  @param u is the root of a tree that is the only one in its group;
     *  (if necessary, the client must call ungroup before calling link)
     *  @param v is a node in some other tree
     */
    link(u, v) {
        fassert(u > 0 && this.p(u) == 0 && v > 0,
                `Forest.link: bad arguments ${u} ${v}`);
        if (u > this.n || v > this.n) {
            this.expand(Math.max(u, v));
        }
        this.#c[v] = this.#sibs.join(this.firstChild(v), u);
        this.#p[u] = v;
    }

    /** Remove a subtree.
     *  @param u is a node in a tree; on return it is a tree root
     */
    cut(u) {
        if (this.p(u) == 0) return;
        let p = this.#p[u]; let firstSib = this.firstChild(p);
        this.#c[p] = this.#sibs.delete(u, firstSib);
        this.#p[u] = 0;
    }

    /** Join two tree groups.
     *  @param r1 is the root of the first tree in some group
     *  @param r2 is the root of the first tree in some other group
     *  @return the root of the first tree in the resulting group
     */
    joinGroups(r1,r2) { return this.#sibs.join(r1,r2); }

    /** Remove a tree from a tree group.
     *  @param r is the root of a tree to be removed from its group
     *  @param r0 is the first root in r's tree group
     *  @return the first root in the modified group
     */
    ungroup(r,r0) { return this.#sibs.delete(r,r0); }
}
</textarea>

<a id=binaryForest><h2>Binary Forest</h2></a>

A <i>binary tree</i> is a tree in which each vertex has at most two children,
and the children are explicitly identified as either the <i>left child</i>
or the <i>right child</i>. 
Binary trees (and forests) are often used to
implement <i>search trees</i> and related data structures.
In these applications, the left-to-right ordering of the vertices
(more precisely, the <i>infix</i> ordering) plays an important role.
The <code>BinaryForest</code> class includes the methods listed below.
More details follow the list.
<ul>
<li>    <code>p(u)</code> returns the parent of vertex <code>u</code>.
<li>    <code>left(u)</code> returns the left child of vertex <code>u</code>.
<li>    <code>right(u)</code> returns the right child of vertex <code>u</code>.
<li>    <code>sibling(u)</code> returns the sibling of vertex <code>u</code>.
        Several other convenience methods are provided for accessing nearby
        vertices; these are omitted for brevity.
<li>    <code>first(u)</code> returns the first vertex in
        <code>u</code>'s subtree.
<li>    <code>next(u,t)</code> returns the next vertex following
        <code>u</code> within <code>t</code>'s subtree (or the entire
        tree containing <code>u</code> if <code>t</code> is omitted.
<li>    <code>root(u)</code> returns the root of the tree containing
        <code>u</code>.
<li>    <code>cut(u)</code> cuts the link between <code>u</code> and its
        parent, making <code>u</code> the root of a separate tree.
<li>    <code>link(u,v,side)</code> links the tree with root <code>u</code>
        to the tree containing <code>v</code>, making <code>v</code>
        the parent of <code>u</code>; <code>u</code> is added as the left
        child of <code>v</code> if <code>side=-1</code> and as the right
        child of <code>side=+1</code>.
<li>    <code>insertAfter(u,t,v)</code> inserts singleton
        <code>u</code> into tree <code>t</code>,
		 immediately after vertex <code>v</code>.
<li>    <code>delete(u,t)</code> removes vertex
        <code>u</code> from tree <code>t</code>.
<li>    <code>join(t1,u,t2)</code> combines two trees
        <code>t1</code> and <code>t2</code> at a singleton <code>u</code>.
        In the resulting tree, the vertices in <code>t1</code> come before
        <code>u</code> in the left-right ordering while the vertices
        in <code>t2</code> come after.
<li>    <code>split(u)</code> divides the tree containing
        <code>u</code> into three parts; <code>t1</code> containing vertices
        that come before <code>u</code>, <code>t2</code> containing vertices
        that come after <code>u</code>, and <code>u</code>.
        The two subtrees are returned.
<li>    <code>insertByKey(u,t,key)</code> inserts singleton
        <code>u</code> into tree <code>t</code>, based on the value of
        <code>key[u]</code>, where <code>key</code> is an array mapping
        vertices to key values. The order of the keys is assumed to match
        the left-to-right order of the vertices in the tree.
<li>    <code>search(k,t,key)</code> searches for a vertex with a specific
        key value <code>k</code> in tree <code>t</code>. The array
        <code>key</code> maps vertices to key values.
<li>    <code>rotate(u)</code> performs a rotation operation, which can
        be used to make a tree &ldquo;more balanced&ldquo; while
        preserving the left-to-right ordering of its vertices.
        This reduces the maximum depth, leading to better performance.
<li>    <code>property(t,p)</code> is used to get or set a numeric property
        of a tree <code>t</code>.
        If the optional argument <code>p</code> is present, it is
        saved as the tree's property. In any case, if a property has been
        defined for a tree, it is returned; otherwise 0 is returned.
</ul>
The data structure includes several operations for modifying trees in the
forest. The <code>cut</code> and <code>link</code> operations are fairly
straightforward. Others require more explanation. The figure below
illustrates the operation <code>insertAfter(c,a,n)</code> operation.
<p>
<div  style="text-align:center;">
<img width="65%" src="figs/insertAfter.png"><br>
</div>
<p>
The inserted vertex <code>c</code> becomes the leftmost leaf in the
right subtree of its specified predecessor <code>n</code>.
<p>
Deleting a vertex from a tree is easy if it has no children.
Just cut the link to the parent. It is almost as easy if it has one
child, since that child can simply take its parent's place in the tree.
To delete an item with two children, its position in the tree is
first swapped with the &ldquo;rightmost vertex&rdquo; in its left subtree.
This vertex is its immediate predecessor in the tree.
At that point, it has at most one child, making the deletion easy.
This is illustrated below.
<p>
<div  style="text-align:center;">
<img width="65%" src="figs/btreeDelete.png"><br>
</div>
<p>
The operation <code>join(t1,u,t2)</code> operation is easy. Simply make 
<code>t1</code> the left child and <code>t2</code> the right child
of <code>u</code>.
The operation <code>split(u)</code> operation
is similarly easy if <code>u</code> is a tree root.
If not, the split is accomplished by starting
at item <code>u</code> and proceeding up the tree, building two subtrees
<code>L</code> and <code>R</code> where <code>L</code> contains
the vertices to the left of <code>u</code> and <code>R</code> contains
the vertices to its right. This is illustrated below.
<p>
<div  style="text-align:center;">
<img width="60%" src="figs/btreeSplit.png"><br>
</div>
<p>
Observe that the first step completes a split of the subtree of
vertex <code>c</code>'s parent <code>b</code>. The next step
completes a split of the next subtree up the path to the root.
The third completes the split for whole tree.
<p>
Binary trees are often used to implement <i>search trees</i> in which
each vertex <code>u</code> is assigned a value <code>key[u]</code> and
the left-to-right order of the search tree vertices matches the
increasing order of the key values, as illustrated below.
<p>
<div  style="text-align:center;">
<img width="35%" src="figs/btreeKeys.png"><br>
</div>
<p>
The operation <code>search(k,t,key)</code> uses the provided key values to
locate a vertex with the specified key. It starts at the root and
at each step compares the key of the current vertex with that of 
<code>u</code>. In the example above <code>search(5,c,key)</code>
follows the path <code>[c,a,i,h,e]</code> from the root, at each
step comparing the key of the current vertex to the target key value
and selecting the left or subtree based on that comparison.
<p>
The operation <code>insertByKeys(u,t,key)</code> is intended for
use in this situation. It starts by using the provided keys to find
a location where <code>u</code> can be inserted as a new leaf,
while ensuring that the order of the tree's vertices remains
consistent with the key values.
In the example above, if <code>key[m]=7</code> the operation
<code>insertByKeys(m,c,key)</code> would search the tree looking
for a viable location, eventually inserting <code>m</code> as the
right child of <code>e</code>.
<p>
The operation <code>rotate(x)</code> is illustrated below.
<p>
<div  style="text-align:center;">
<img width="45%" src="figs/bstRotate.png"><br>
</div>
<p>
Notice that the operation moves <code>x</code> one step closer
to the root and moves its parent one step further away.
If applied in a systematic fashion, rotations can be used to
reduce the maximum depth of a tree.
In particular,
the <code>BalancedForest</code> data structure (see next sub-section)
uses rotations to ensure that the tree depth is never more than
twice the log of the tree size.
<p>
Rotations are often used in pairs.
In particular, when $x$ is an <i>outer grandchild</i>,
a double-rotation at $x$ consists of a first rotation at its parent,
then a rotation at $x$, as illustrated below.
<p>
<div  style="text-align:center;">
<img width="45%" src="figs/bstRotate2a.png"><br>
</div>
<p>
When $x$ is an <i>inner grandchild</i>,
both rotations are done at $x$.
<p>
<div  style="text-align:center;">
<img width="45%" src="figs/bstRotate2b.png"><br>
</div>
<p>
The core of the <i>Javascript</i> implementation appears below.
<p>
<textarea id="components" rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class BinaryForest extends Top {
    #left;      // #left[u] is left child of u
    #right;     // #right[u] is right child of u
    #p;         // #p[u] is parent of u

    /** Constructor for BinaryForest object.
     *  @param n is index range for object
     *  @param capacity is maximum index range (defaults to n)
     */
    constructor(n=10, capacity=n) {
        super(n);
        this.#left = new Int32Array(capacity+1);
        this.#right = new Int32Array(capacity+1);
        this.#p = new Int32Array(capacity+1);
    }

    /* Get or set the left child of a node.
     * @param u is a node
     * @param v is an optional new left child for u
     * @return the left child of u
     */
    left(u, v=-1) {
        if (v >= 0) this.#left[u] = v;
        return this.#left[u];
    }

    /* Get or set the right child of a node. */
    right(u, v=-1) {
        if (v >= 0) this.#right[u] = v;
        return this.#right[u];
    }

    /* Get or set the parent of a node. */
    p(u, v=-1) {
        if (v >= 0) this.#p[u] = v;
        return this.isroot(u) ? 0 : this.#p[u];
    }

    /* Get or set a property of a tree.
     * @param t is a tree root
     * @param p is an optional property to be assigned to the root;
     * properties must be non-negative integers (Int32).
     * @return the property of t
     */
    property(t, p=-1) {
        fassert(this.isroot(t),
                `BinaryForest.property: ${this.x2s(t)} ${this.#p[t]}`);
        if (p >= 0) this.#p[t] = -p;
        return -this.#p[t]
    }

    /* Determine if a node is a tree root, */
    isroot(r) { return r && this.#p[r] <= 0; }

    /* Get the sibling of a node. */
    sibling(u) {
        let p = this.p(u);
        return (u == this.left(p) ? this.right(p) : this.left(p));
    }

    /** Get grandparent of a node. */
    gp(x) { return this.p(this.p(x)); }

    /** Get aunt of a node (parent's sibling) */
    aunt(x) { return this.sibling(this.p(x)); }

    /** Get nephew of a node (far child of sibling) */
    nephew(x) {
        return this.outerChild(this.sibling(x));
    }

    /** Get niece of a node (near child of sibling) */
    niece(x) {
        return this.innerChild(this.sibling(x));
    }

    /** Determine if node is an inner grandchild. */
    innerGrandchild(x) {
        let gp = this.gp(x);
        return x != 0 && (x == this.left(this.right(gp)) ||
                          x == this.right(this.left(gp))); 
    }

    /** Determine if node is an outer grandchild. */
    outerGrandchild(x) {
        let gp = this.gp(x);
        return x != 0 && (x == this.left(this.left(gp)) ||
                          x == this.right(this.right(gp))); 
    }

    /** Determine if node is a singleton. */
    singleton(u) {
        return this.isroot(u) && this.left(u) == 0 && this.right(u) == 0;
    }

    // Methods for tree iteration. Iterates through nodes in "infix" order,
    // (that is, left-to-right). Note, iterating through a subtree of
    // of k nodes takes time proportional to k, although individual
    // steps may take more than constant time.

    /** Get the leftmost node in a subtree. */
    first(u) {
        while (this.left(u)) { u = this.left(u); this.steps++; }
        return u;
    }

    /** Get the next node to the right within a subtree. */
    next(u,root=0) {
        if (this.right(u)) return this.first(this.right(u));
        let c = u; u = this.p(u);
        while (u != this.p(root) && c == this.right(u)) {
            c = u; u = this.p(u); this.steps++;
        }
        return u != this.p(root) ? u : 0;
    }

    /** Get the rightmost node in a subtree. */
    last(u) {
        while (this.right(u)) { u = this.right(u); this.steps++; }
        return u;
    }

    /** Get the next node to the left within a subtree. */
    prev(u,root=0) {
        if (this.left(u) != 0) {
            for (u = this.left(u); this.right(u); u = this.right(u)) {
                this.steps++;
            }
            return u;
        }
        let c = u; u = this.p(u);
        while (u != this.p(root) && c == this.left(u)) {
            c = u; u = this.p(u); this.steps++;
        }
        return u != this.p(root) ? u : 0;
    }

    /** Find the root of the tree containing u. */
    root(u) {
        while (!this.isroot(u)) {
            u = this.p(u); this.steps++;
        }
        return u;
    }

    /** Remove a subtree.  */
    cut(u) {
        let pu = this.p(u);
        if (!this.isroot(u) && u == this.left(pu))  this.left(pu,0);
        if (!this.isroot(u) && u == this.right(pu)) this.right(pu,0);
        this.p(u,0);
        return u;
    }

    /** Link one tree to another.
     *  @param u is a tree root or 0
     *  @param v is a node in a different tree
     *  @param side specifies which child of v that u should become;
     *  -1 means left, +1 means right and 0 means don't care
     */
    link(u,v,side=0) {
        fassert(v != 0);
        if (u) this.p(u,v);
        if (side < 0) {
            this.left(v,u);
        } else if (side > 0) {
            this.right(v,u);
        } else {
            if (this.left(v) && !this.right(v))
                this.right(v,u);
            else if (!this.left(v) && this.right(v))
                this.left(v,u);
            else if (Math.random() < 0.5)
                this.left(v,u);
            else
                this.right(v,u);
        }
    }
    
    /** Insert a node immediately after another vertes in a tree.
     *  @param u is a singleton
     *  @param t is the root of a tree
     *  @param v is a vertes in a tree which defines the point where u is
     *  to be inserted; if zero, u is inserted before all nodes in tree
     *  @param refresh(u) is an optional function that can be used to adjust
     *  client data that is affected by the tree structure; it is called
     *  just after u is inserted
     *  @return the root of the resuling tree
     */
    insertAfter(u, t, v, refresh=0) {
        if (t == u) return u;
        if (!v)
            this.link(u, this.first(t), -1);
        else if (!this.right(v))
            this.link(u, v, +1);
        else
            this.link(u, this.first(this.right(v)), -1);
        if (refresh) refresh(u);
        return this.root(t);
    }

    /** Delete a node from a tree.
     *  @param u is a non-singleton tree node.
     *  @param t is the tree containing u
     *  @param refresh(cu,pu) is an optional function which can be used
     *  to adjust client data that is affected by the tree structure;
     *  it is called just after u's removal and its arguments are u's former
     *  child and parent
     *  @return the resulting tree
     */
    delete(u, t=this.root(u), refresh=0) {
        if (this.singleton(u)) return u;
        // find a node close to the root
        let tt = (u != t ? t : (this.left(u) ? this.left(u) : this.right(u)));
        if (this.left(u) && this.right(u))
            this.swap(u, this.prev(u)); 
        // now, u has at most one child
        let cu = (this.left(u) ? this.left(u) : this.right(u));
        // cu is now the only child that could be non-zero
        let pu = this.p(u);
        if (cu != 0) this.p(cu, pu);
        if (pu != 0) {
                 if (u ==  this.left(pu))  this.left(pu, cu);
            else if (u == this.right(pu)) this.right(pu, cu);
        }
        this.p(u,0); this.left(u,0); this.right(u,0);
        if (refresh) refresh(cu,pu);
        tt = this.root(tt);
        return tt;
    }

    /** Swap the positions of two nodes in same tree.
     *  @param u is a node in the tree
     *  @param v is another node in the same tree
     */
    swap(u, v) {
        this.steps++;
        // save pointer fields for nodes u and v
        let lu = this.left(u); let ru = this.right(u);
        let lv = this.left(v); let rv = this.right(v);
        let pu = this.#p[u]; let pv = this.#p[v];
            // special handling of parent field to deal with tree property
    
        // fixup fields in u's neighbors
        if (lu != 0) this.p(lu, v);
        if (ru != 0) this.p(ru, v);
        if (!this.isroot(u)) {
            if (u == this.left(pu)) this.left(pu, v);
            else this.right(pu, v);
        }
        // fixup fields in j's neighbors
        if (lv != 0) this.p(lv, u);
        if (rv != 0) this.p(rv, u);
        if (!this.isroot(v) != 0) {
            if (v == this.left(pv)) this.left(pv, u);
            else this.right(pv, u);
        }
    
        // update fields in nodes u and v
        this.left(u, lv); this.right(u, rv); this.#p[u] = pv;
        this.left(v, lu); this.right(v, ru); this.#p[v] = pu;
    
        // final fixup for the case that u was originally the parent of v
             if (v == lu) { this.left(v, u); this.p(u, v); }
        else if (v == ru) { this.right(v, u); this.p(u, v); }
    }

    /** Join two trees (or subtrees) at a node.
     *  @param t1 is a tree
     *  @param u is a node
     *  @param t2 is a second tree
     *  @param refresh(u) is an optional function that can be used to adjust
     *  client data that is affected by the tree structure; it is called
     *  at the conclusion of the operation.
     *  @return root of new tree making t1 the left subtree of u
     *  and t2 the right subtree
     */
    join(t1, u, t2, refresh=0) {
        this.link(t1,u,-1); this.link(t2,u,+1); this.p(u,0);
        if (refresh) refresh(u);
        return u;
    }

    /** Split a tree on a node.
     *  @param u is a node in a tree
     *  @param refresh(u) is an optional function that can be used to adjust
     *  client data that is affected by the tree structure; it is called
     *  at the conclusion of the split.
     *  @return a pair [t1,t2] where t1 has the nodes that were to the
     *  the left of u and t2 has the nodes that were to the right of u
     */
    split(u, refresh=0) {
        fassert(this.valid(u));
        let v = u; let p = this.p(v);
        let [l,r] = [this.left(u), this.right(u)];
        this.left(u,0); this.right(u,0); this.p(u,0);
        while (p > 0) {
            this.steps++;
            let gp = this.p(p); this.p(p,0); // isolate p's subtree
            if (v == this.left(p)) {
                r = this.join(r,p,this.right(p),refresh);
            } else {
                  l = this.join(this.left(p),p,l,refresh);
            }
            v = p; p = gp;
        }
        this.p(l,0); this.p(r,0);
        if (refresh) refresh(u);
        return [l,r];
    }

    /** Insert a node based on a key value.
     *  @param u is a singleton node
     *  @param key is an array mapping nodes to key values;
     *  the trees are assumed to be ordered by the keys
     *  @param t is the root of some tree.
     *  @param refresh(u) is an optional function that can be used to adjust
     *  client data that is affected by the tree structure; it is called
     *  just after u is inserted
     *  @return the root of the modified tree
     */
    insertByKey(u, t, key, refresh=0) {
        if (!t || t == u) return u;
        let v = t; let pv = 0;
        while (v != 0) {
            pv = v; this.steps++;
            if (key[u] <= key[v]) v = this.left(v);
            else                  v = this.right(v);
        }
        this.link(u, pv, key[u] <= key[pv] ? -1 : +1);
        if (refresh) refresh(u);
        return this.root(t);
    }

    /** Search for an item with a specified key
     *  @param k is a specific key value to be located
     *  @param t is the root of the tree (or subtree) to be searched
     *  @param key is an array mapping each node to a key value;
     *  the tree nodes are assumed to be ordered according to key
     *  @return node u where key[u]==k or 0 if there is no such node
     */
    search(k, t, key) {
        let u = t;
        while (u != 0 && key[u] != k) {
            this.steps++;
            if (k < key[u]) u = this.left(u);
            else            u = this.right(u);
        }
        return u;
    }
        
    /** Append one tree after another
     *  @param u is the root of tree
     *  @param v is the root of a second tree
     *  @return subtree formed by combining the two with the nodes
     *  in v's subtree to the right of the nodes in u's subtree
     */
    append(u,v) {
        if (u == 0 || u == v) return v;
        else if (v == 0) return u;
        let t = this.last(u);
        let [t1] = this.split(t);
        t = this.join(t1,t,v);
        return t;
    }

    /** Perform a rotation in a tree.
     *  @param x is a node in some tree; this method
     *  moves x up into its parent's position, while maintaining the
     *  left-to-right order of the tree nodes
     */
    rotate(x) {
        this.steps++; this.rotations++;
        let px = this.p(x); let gpx = this.#p[px];
        if (px == 0) return;
        let cx = 0;
        if (x == this.left(px)) {
            cx = this.right(x); this.left(px, cx); this.right(x, px);
        } else {
            cx = this.left(x); this.right(px, cx); this.left(x, px);
        }
        this.p(px, x); if (cx != 0) this.p(cx, px);
        if (gpx > 0) {
            if (px == this.left(gpx)) {
                this.left(gpx, x);
            } else if (px == this.right(gpx)) {
                this.right(gpx, x);
            }
        }
        this.#p[x] = gpx;
    }

    /** Perform a double-rotation on a tree.
     *  @param x is a node in the tree; the operation moves x into
     *  its grandparent's position. Note that this is not the same
     *  as simply doing two successive rotations at x.
     */
    rotate2(x) {
        if (this.outerGrandchild(x))  {
            this.rotate(this.p(x)); this.rotate(x); 
        } else if (this.innerGrandchild(x)) {
            this.rotate(x); this.rotate(x); 
        }
    }
}
</textarea> <p>
Notice that most methods that modify a tree's structure
provide an optional function argument called <code>refresh</code>.
These functions can be used to assist in balancing the data structure,
and/or maintaining client data that may be affected by the
tree structure.

<a id=balancedForest><h2>Balanced Forest</h2></a>
The <i>balanced forest</i> data structure extends the <i>binary forest</i>
in order to improve its worst-case performance.
There are many ways to keep the trees balanced, so that the maximum
height of the trees is $O(\log n)$. One method [Bayer72, Tarjan87] assigns
a <i>rank</i> to every node, so that the ranks satisfy two properties.
$$
rank(u) \leq rank(p(u)) \leq rank(u) +1 \\
rank(u) < rank(gp(u))
$$
where $gp(u)$ is the grandparent of $u$.
Vertices with fewer than two children are assigned a rank of 1.
An example of such a tree is shown below.
<p>
<div  style="text-align:center;">
<img width="35%" src="figs/bstb.png"><br>
</div>
<p>
One can show by induction that any node of rank $k$ has height at
most $2k-1$ and has at least $2^k-1$ descendants.
This implies that the maximum depth of any node
is $\leq 2 \lfloor\lg (n+1)\rfloor$.
<p>
Operations that modify a tree must be extended to
to ensure that the conditions on the ranks are maintained.
Following an insertion of a node $x$, one must compare
$rank(x)$ with $rank(gp(x))$. If $rank(x)$ is smaller,
nothing further needs to be done. If the two ranks are equal,
but $x$'s aunt (the sibling of its parent) has smaller rank,
the rank conditions can be
satisfied by doing one or two rotations.
Specifically, if $x$ is an outer grandchild,
a single rotation at $p(x)$ completes the process.
If $x$ is an inner grandchild,
a double-rotation at $x$ is required.
This is illustrated below.
<p>
<div  style="text-align:center;">
<img width="50%" src="figs/bstbBalanced1.png"><br>
</div>
<p>
If $rank(x)=rank(gp(x))=rank(aunt(x))$, $rank(gp(x))$ is
incremented and the checking procedure is repeated at $gp(x)$
<p>
The procedure for balancing after a deletion is a bit more involved.
It starts at the vertex $x$ that took the place of the deleted node.
Let $r$ be its rank. There are four case to consider.
(Case 1) If $x$'s parent has rank $r+2$ then there is a
violation of the first rank condition that needs to be fixed.
If $x$'s sibling also has rank $r+2$, a rotation is performed
at the sibling, as illustrated below.
<p>
<div  style="text-align:center;">
<img width="40%" src="figs/bstbBal2a.png"><br>
</div>
<p>
This rotation does not fix the rank violation at $x$,
but because $x$'s new sibling has rank $r+1$, the violation can
now be addressed using one of the three remaining cases.
<p>
(Case 2) If $x$'s sibling has rank $r+1$ and both of its children have
rank $r$, then $rank(p(x))$ is decremented, eliminating the rank
violation at $x$, but possibly creating a new violation between
$p(x)$ and its parent. In this case, the checking process is repeated,
with $p(x)$ replacing $x$.
<p>
<div  style="text-align:center;">
<img width="20%" src="figs/bstbBal2b.png"><br>
</div>
<p>
(Case 3) If $x$'s sibling has rank $r+1$ and $x$'s <i>nephew</i>
(the more distant child of $x$'s sibling)
has rank $r+1$, a rotation is performed at
the sibling and the ranks of $x$'s parent and its new grandparent
are changed to $r+1$ and $r+2$ respectively.
<p>
<div  style="text-align:center;">
<img width="40%" src="figs/bstbBal2c.png"><br>
</div>
<p>
(Case 4) Finally, if $x$'s sibling has rank $r+1$
and its <i>neice</i> has rank $r+1$, a double rotation is performed at
the neice and the ranks of $x$'s parent and grandparent
are changed to $r+1$ and $r+2$.
<p>
<div  style="text-align:center;">
<img width="40%" src="figs/bstbBal2d.png"><br>
</div>
<p>
Note that the last two cases eliminate the violation at $x$ and create
no new violations, so the rebalancing process ends at that point.
Also, if an application of the first case is followed by an application
of the second case, there can be no remaining violation of the
rank condition at that point.
<p>
The operation $join(t_1,i,t_2)$ can be performed as before,
if $rank(t_1)=rank(t_2)$. In this case, $rank(i)$ is set to $rank(t_1)+1$.
If $rank(t_1) \neq rank(t_2)$, things get more complicated.
If $rank(t_1) > rank(t_2)$, the first step is to follow right pointers
from $t_1$ looking for the first vertex $v$ with $rank(v)=rank(t_2)$.
The subtree at $v$ is then joined to $i$ and $t_2$ and the
resulting subtree takes the original place of $v$ in $t_1$.
This is illustrated below.
<p>
<div  style="text-align:center;">
<img width="60%" src="figs/bstbJoin.png"><br>
</div>
<p>
Since this procedure may produce a violation of the second rank condition,
the rebalancing procedure used for inserts is applied at this point,
starting at $i$.
<p>
The <i>split</i> operation is done as before, but uses the balanced
version of the <i>join</i> operation in place of the original.
<p>
The core of the <code>BalancedSets</code> class is shown below.
<p>
<textarea id="components" rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class BalancedForest extends BinaryForest {
    #rank;        // #rank[u] is an optional field used to maintain tree balance

    constructor(n=10, capacity=n) {
        super(n, capacity);
        this.#rank = new Int8Array(this.capacity+1).fill(1,1);
    }

    /* Get or set the rank child of a node.
     * @param u is a node
     * @param r is an optional new rank for u
     * @return the rank of u
     */
    rank(u, r=-1) {
        if (r >= 0) this.#rank[u] = r;
        return this.#rank[u];
    }
    
    /** Insert a singleton immediately after another node in a tree.
     *  @param u is a singleton
	 *  @param t is root of tree into which u is to be inserted
     *  @param v is a node in a tree which defines the point where u is
     *  to be inserted; if zero, u is inserted before all nodes in tree
     *  @param refresh(u) is an optional function that can be used to adjust
     *  client data that is affected by the tree structure; it is called
     *  just before the tree is rebalanced.
     *  @param t is the tree root
     */
    insertAfter(u, t, v, refresh=0) {
        return super.insertAfter(u, v, t,  u => { if (refresh) refresh(u);
                                                this.rerankUp(u);
                                                });
    }

    /** Insert a node based on a key value.
     *  @param u is a singleton node
     *  @param key is an array mapping nodes to key values;
     *  @param t is the root of the tree containing u
     *  @param refresh(u) is an optional function, which is called
     *  with argument u after u is inserted but before rebalancing.
     *  @return the root of the modified tree
     */
    insertByKey(u, t, key, refresh=0) {
        return super.insertByKey(u, t, key, u => { if (refresh) refresh(u);
                                                 this.rerankUp(u);
                                                 });
    }

    /** Delete a node from a tree.
     *  @param u is a non-singleton tree node.
     *  @param t is the tree containing u
     *  @param refresh(pu) is an optional function that can be used to adjust
     *  client data that is affected by the tree structure; it is called
     *  just before the tree is rebalanced and its argument is u's parent
     *  just before the rebalancing takes place.
     *  @return the modified tree
     */
    delete(u, t=0, refresh=0) {
        t = super.delete(u, t, (cu,pu) => { if (refresh) refresh(pu);
                                             this.rerankDown(cu,pu);
                                            });
        this.rank(u,1);
        return t;
    }

    swap(u, v) {
        super.swap(u,v);
        let ru = this.rank(u); this.rank(u, this.rank(v)); this.rank(v, ru);
    }

    /** Join two trees (or subtrees) at a node.
     *  @param t1 is a tree
     *  @param u is a node
     *  @param t2 is a second tree (likewise)
     *  @param refresh is an optional function 
     *  @param refresh(pu) is an optional function that can be used to adjust
     *  client data that is affected by the tree structure; it is called
     *  just before the tree is rebalanced and its argument is u's parent
     *  just before the rebalancing takes place.
     *  @return root of new tree (or subtree) formed by joining t1, u and t2.
     */
    join(t1, u, t2, refresh=0) {
        let r1 = this.rank(t1); let r2 = this.rank(t2);
        if (r1 == r2) {
            let t = super.join(t1,u,t2); this.rank(t, r1+1);
            return t;
        }
        if (r1 > r2) {
            let v = t1; let pv = 0;        // track parent in case t2==0
            while (this.rank(v) > r2) {
                pv = v; v = this.right(v); this.steps++;
            }
            // now, rank(v) == rank(t2)
            super.join(v, u, t2);
            this.link(u,pv,+1); this.rank(u, r2+1);
            this.p(t1,0);
            if (refresh) refresh(u);
            this.rerankUp(u);
            let t =  this.root(t1);
            return t;
        } else { // (r1 < r2)  mirror of first case
            let v = t2; let pv = 0;        // track parent in case t1==0
            while (this.rank(v) > r1) {
                pv = v; v = this.left(v); this.steps++;
            }
            super.join(t1, u, v);
            this.link(u,pv,-1); this.rank(u, r1+1)
            this.p(t2,0);
            if (refresh) refresh(u);
            this.rerankUp(u);
            let t = this.root(t2);
            return t;
        }
    }

    split(u, refresh=0) {
        let pair = super.split(u, refresh); this.rank(u,1); return pair;
    }

    /** Adjust ranks after a node rank increases, leading to a violation
     *  of the rank invariant; may do up to two rotations, as well;
     *  assumes that other nodes satisfy the invariant.
     *  @param x is a node whose rank may equal that of its grandparent, 
     *  in violation of the rank invariant for balanced trees.
     */ 
    rerankUp(x) {
        let rx = this.rank(x);
        while (this.gp(x) != 0 && this.rank(this.gp(x)) == rx &&
                                  this.rank(this.aunt(x)) == rx) {
            x = this.gp(x); rx = this.rank(x,rx+1); this.steps++;
        }
        if (this.gp(x) == 0 || rx != this.rank(this.gp(x)))
            return;
        if (this.outerGrandchild(x)) this.rotate(this.p(x));
        else this.rotate2(x);
    }

    /** Adjust ranks after the rank of a node decreases, leading to a
     *  violation in the rank invariant; may do up to two rotations;
     *  assumes that other nodes satisfy the invariant.
     *  @param x is a node in a tree or 0; the rank at x may be too small
     *  for its parent (by 1).
     *  @param px is the parent of x, or a node with a null child, if x=0
     */
    rerankDown(x, px) {
        let r = this.rank(x);
        while (this.rank(px) == r+2) {
            this.steps++;
            let sx, nefu, nece;
            if (x != 0) {
                sx = this.sibling(x); nefu= this.nephew(x); nece= this.niece(x);
            } else if (this.left(px) != 0) { // && x == 0
                sx = this.left(px); nefu = this.left(sx); nece = this.right(sx);
            } else { // x == 0 && right(px) != 0
                sx = this.right(px); nefu = this.right(sx); nece= this.left(sx);
            }
            if (this.rank(sx) == r+2) {
                this.rotate(sx);
                // rank(sibling(x)) is now r+1, so on next iteration,
                // next case applies;
                // also, rank(p(x)) == rank(gp(x)) == r+2
            } else { // rank(sx) == r+1
                if (this.rank(nefu) == r && this.rank(nece) == r) {
                    x = px; px = this.p(x); r = this.rank(x,r+1);
                } else { // rank(nefu) = r+1 or rank(nece) = r+1
                    if (this.rank(nefu) == r+1) this.rotate(sx);
                    else                          this.rotate2(nece);
                    this.rank(px, r+1); this.rank(this.p(px), r+2);
                    return;
                }
            }
        }
    }
}
</textarea> <p>
Observe how the <code>refresh</code> function arguments are used
to implement the re-balancing.

<a id=splayForest><h2>Splay Forest</h2></a>

Another way to improve the performance of binary trees is using
<i>splay trees</i> [Tarjan87].
Splay trees require no explicit balance information, but by restructuring
trees routinely during normal operations they can perform an arbitrary
sequence of $m$ tree operations in $O(m\log n)$ time.
While some individual operations may still be expensive,
the time for the sequence remains bounded.
<p>
The key to this approach is a restructuring operation called a <i>splay</i>.
A splay at a vertex $u$ consists of a series of double rotations at $u$,
that moves $u$ to the root, or at most one step away. If needed, a
final single rotation is used to bring $u$ to the root.
An example is shown below.
<p>
<div  style="text-align:center;">
<img width="80%" src="figs/bstSplay.png"><br>
</div>
<p>
To understand why the splay is helpful,
note that any double-rotation at a vertex $u$ brings the descendants of $u$
at least one step closer to the root of the search tree.
Consequently, a splay at a vertex $u$ that is far from the root reduces
the depth of $u$'s original descendants by roughly a factor of two
(possibly more for some of them).
A similar thing happens for $u$'s original ancestors.
Once an ancestor becomes a descendant of $u$, it benefits in the same way.
That is, its distance to the root is reduced by roughly a factor of two.
Even a vertex $p$ that is not an ancestor of $u$ can benefit, since it also
starts moving closer to the tree root, once $u$ passes $p$'s ancestor on
the original path from $u$ to the root.
<p>
When a <i>search</i> operation reaches a vertex with the target key,
a splay is performed at that vertex, improving the performance of future
operations while only increasing the cost of the search by a
constant factor.
Similarly, a splay is performed after a vertex is inserted or deleted.  
No splay is performed during a <i>join</i>, but a <i>split</i>
is implemented by first performing a splay at the split vertex $u$ and
then simply separating the two subtrees of the new root, $u$.
<p>
An amortized complexity analysis can be used to show that the time
required to do a sequence of $m$ operations on a collection of
splay trees is $O(n + m\log n)$ or $O(m\log n)$ in the common case
where $m\geq n$.
As usual, operations are paid for with credits and any excess
credits not needed for a particular operation can be carried over
to pay for future operations.
To ensure that there are always enough credits on hand,
the following credit policy is used.
<p style="padding-left:5%;">
For each vertex of $u$, maintain $rank(u)$ credits, where
$$rank(u)= \lfloor \lg (\textrm{the number of descendants of }u)\rfloor$$
<p>
To determine the number of credits needed for a splay at vertex $u$,
let's first determine the number needed for one double-rotation.
Let $v$ be the parent of $u$ and $w$ its grandparent and let
$rank'$ denote the rank values after the rotation
(note that $rank'(u)=rank(w)$).
The number of credits needed to satisfy the credit policy following a double
rotation is 
\begin{eqnarray*}
(rank'(u)-rank(u)) &+& (rank'(v)-rank(v)) + (rank'(w)-rank(w)) \\
&=&(rank'(w)+rank'(v)) - (rank(u)+rank(v)) \\
&\leq& 2(rank(w) - rank(u))
\end{eqnarray*}
If $rank(u) < rank(w)$ and $3(rank(w) - rank(u))$ credits are allocated
for the double rotation, there will be at least one credit available
to pay for the operation, while still satisfying the credit policy.
<p>
Now consider the case where $rank(u)=rank(w)$.
If $u$ is an inner grandchild, then after the double-rotation,
$v$ and $w$ are its children, meaning that at least one of them has a smaller
rank after the operation. This implies that there is one less credit needed to
satisfy the credit policy after the operation, and this credit can
be used to pay for it.
If $u$ is an outer grandchild, then $u$ has at least $2^r$ descendants and 
$w$ has has fewer than $2^r$ descendants outside of $u$'s subtree.
This implies that after the operation $w$ has fewer than
$2^r$ descendants, making $rank'(w) < r$.
<p>
<div  style="text-align:center;">
<img width="50%" src="figs/bstCredit1.png"><br>
</div>
<p>
So again, one less credit is needed to satisfy the credit policy and
that credit can be used to pay for the operation.
Summarizing, if $3(rank(w)-rank(u))$ credits are allocated to each
double rotation, the operation can be paid for while continuing to
satisfy the credit policy.
<p>
If a single rotation is required to complete a splay, the number of
credits needed to satisfy the credit policy after the operation is
$$
(rank'(u)-rank(u)) + (rank'(v)-rank(v)) 
=rank'(v) - rank(u) \leq rank(v) - rank(u)
$$
If $3(rank(v) - rank(u))+1$ credits are allocated for the rotation,
it can be paid for while still satisfying the credit policy.
These observations are summarized in the following lemma.
<p>
<i>Lemma</i>. Let $u$ be a vertex in a tree with root $v$.
If $3(rank(v)-rank(u))+1$ credits are allocated to a splay operation
at $u$, the operation can be fully paid for while continuing to
satisfy the credit policy.
<p>
Note that this implies that at most $3\lfloor \lg n \rfloor+1$ credits
are needed for each splay.
The next step in the analysis of splay trees is to determine the number
of credits that must be allocated to each operation in addition to those
required for splays.
For an <i>insert</i> operation, the vertex along the path from the inserted
vertex to the root all acquire a new descendant and consequently,
the ranks will increase for those vertices that have
exactly $2^k-1$ descendants before the insertion.
There are at most $\lfloor \lg n \rfloor+1$ such vertices, so the
total number of credits needed for the insert (including the splay) is
$\leq 4(\lfloor \lg n \rfloor)+3$. 
<p>
The <i>join</i> requires an additional $\lfloor \lg n \rfloor+1$ credits to
satisfy the credit policy at the new tree root,
and since no splay is involved, $\lfloor \lg n \rfloor+2$ credits are
sufficient to pay for the operation
while continuing to satisfy the credit policy.
<p>
The other operations require just one credit beyond those needed for
the splay, so the total number of credits required for $m$ operations
is $O(m\log n)$. The initialization can be paid for with $n$ credits and
no additional credits are needed to satisfy the credit policy initially.
Since every operation is paid for with allocated credits and the number of
credits allocated is $O(n + m \log n)$, the time required for the operations
is also $O(n + m \log n)$.
<p>
The splay lemma is also true using a more general
definition of the $rank$. Specifically, if each vertex $u$ is assigned some
arbitrary <i>weight</i> $w(u)$ and $tw(u)$ is defined as the total weight
of the subtree with root $u$, then $rank(u)$ can be defined as
$\lfloor \lg tw(u) \rfloor$. The argument used earlier still works with
this definition. The more general version is used in a later section
to analyze the performance of the dynamic trees data structure.
<p>
The core of the <i>Javascript</i> implementation of the
<code>SplayForest</code> class is shown below.
<p>
<textarea id="components" rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class SplayForest extends BinaryForest {

    constructor(n=10, capacity=n) { super(n,capacity); }

    splay(x) {
        for (let y = this.p(x); y; y = this.p(x)) {
            let z = this.p(y);
            if (z) this.rotate(this.outerGrandchild(x) ? y : x)
            this.rotate(x);
        }
        return x;
    }

    find(u, nosplay=false) {
        return nosplay ? super.root(u) : this.splay(u);
    }

    search(k, t, key) {
        return this.splay(super.search(k, t, key));
    }

    insertByKey(u, t, key) {
        return super.insertByKey(u, t, key, u => this.splay(u));
    }

    delete(u,t=0) {
        return super.delete(u, t, (cu,pu) => { this.splay(pu); });
    }

    split(u) { this.splay(u); return super.split(u); }
}
</textarea> <p>
In practice, the balanced binary tree is generally more efficient than
the splay tree, since the rotations required for each splay are
relatively expensive operations.
However, there are some special cases, where the splay tree is
technically superior.

<h2>References</h2>
<dl>
<dt> [Bayer72]
<dd> &ldquo;Symmetric binary B-trees: Data structure and maintenance
     algorithms,&rdquo; by R. Bayer. In <i>Acta Informatica</i> 1972.
<dt> [Tarjan87]
<dd> <i>Network Algorithms and Data Structures</i> by Robert E. Tarjan.
     Society for Industrial and Applied Mathematics, 1987.
</dl>
<hr> <h4>&copy; Jonathan Turner - 2022</h4>
<script src="../googleAnalytics.js"></script>
</body>
</html>
