<html>
<head>
<title>Introduction</title>
<link type="text/css" rel="stylesheet" href="../main.css">
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</head>
<body bgcolor=ffffff>
<h1>Basic Data Structures<sup>&copy;</sup></h1>
<p>
This page describes a number of basic data structures used by the
various algorithms and as building blocks within more complex data structures.

<h2>Introduction</h2>

Many of the algorithms described on this site require multiple
data structures that address different aspects of the problem being solved.
Because the data structures are closely related, there must be a way to
maintain correspondences among them.
One simple way to do this is
with <i>index-based data structures</i>.
Here is an example of an index-based list used to represent the list
of distinct integers $[7,5,3,8,2]$. In general, an index list
can be used to represent any list of distinct positive integers within a bounded
range, in this case, 1 to 10.
<p>
<div  style="text-align:center;">
<img width="450" src="figs/indexList.png"><br>
</div>
<p>
The list is represented by a vector $\textit{next}$, which identifies the next
item in the list. So for example $\textit{next}[7] = 5$ as you would expect.
Notice that $\textit{next}[2] = 0$ to indicate the end of the list. For the
integers in $1\ldots 10$ that are not in the list,
the value of $\textit{next}$ is $-1$.
This allows us to implement a constant-time test to determine if a given
value is in the list. A list like this could be used to represent a queue
containing some of the vertices in a graph. The linked representation allows
us to easily remove the first element or add a new element to the end,
while the constant-time membership test allows us to quickly determine if
a given vertex is in the queue.
<p>
Here is another example of an index-based data structure, which defines a
collection of disjoint lists that partition the index set $1\ldots 12$ into
the six subsets $\{[1, 6, 3], [4], [2, 7], [8], [11, 9], [5, 12, 10]\}$. This list is doubly-linked with the <code>next</code> and <code>prev</code>
arrays defining the neighbors of each list item.
<p>
<div  style="text-align:center;">
<img width="500" src="figs/dlists.png"><br>
</div>
<p>
Observe that the colors highlight items in the same list.
Also, note that the $\textit{next}$ value for the last item on each list is 0 to mark
the end of the list. However, the $\textit{prev}$ value of the first
item on each list is not 0. Instead, it points to the last item in the list.

All the algorithms and data structures described on the site have been
implemented as <i>javascript</i> modules.
Here is an example of one of the basic algorithms that is available.
It uses the index list data structure and the disjoint lists data structure,
as well as a data structure for an undirected graph.
Note that the code below is enclosed in a scrollable text area.
<p>
<textarea rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
import List from '../../dataStructures/basic/List.mjs';
import ListSet from '../../dataStructures/basic/ListSet.mjs';

/** Identify the connected components of an undirected graph.
 *  @param g is a graph object
 *  @param trace is an optional argument that controls production of trace
 *  information; when zero, no trace information is provided
 *  @return a pair [k, comps, traceString] where k is the number of components
 *  in g and comps is a ListSet object that partitions
 *  the vertices into subsets that define each component and traceString
 *  contains trace information.
 */
export default function components(g, trace=0) {
    let k = 0; let traceString = '';
    if (trace) traceString += g + '\n';
    let comps = new ListSet(g.n);
    let q = new List(g.n);
    if (trace)
        traceString += 'selected vertex, queue, components\n'
    for (let s = 1; s <= g.n; s++) {
        if (!comps.singleton(s)) continue;
        k++; q.enq(s);
        while (!q.empty()) {
            let u = q.deq();
            for (let e = g.firstAt(u); e != 0; e = g.nextAt(u,e)) {
                let v = g.mate(u,e);
                if (comps.singleton(v)) {
                    comps.join(s, v); q.enq(v);
                }
            }
            if (trace)
                traceString += `${g.index2string(u)} ${q} ${comps}\n`
        }
    }
    comps.sort();
    return [k, comps, traceString];
}
</textarea>
<p>
The function <code>components</code> identifies the individual
connected components of a graph and returns the number of components,
a <code>ListSet</code> object that contains a separate list for the vertices
in each component and a <i>trace string</i> that captures trace information
detailing the steps in the function's execution.
The tracing feature is enabled by the optional <i>trace</i> argument.
Most of the provided code modules include a similar trace feature.
<p>
The <code>ListSet</code> object <code>comps</code> is defined on the integers
1 to <code>g.n</code>, where <code>g.n</code>
is the number of vertices in the <code>graph</code> object <code>g</code>.
The outer loop scans the set of vertices looking for a vertex <code>s</code>
which is not
in any component already identified, while the inner loop implements
a breadth-first search over the component containing <code>s</code>,
combining all of its vertices into a single list in <code>ListSet</code>.
The <code>singleton()</code> method returns true if its argument is the
only item in its list.
The <code>enq()</code> and <code>deq()</code> methods are used to add
an item to the end of a list or remove the first item.
The <code>firstAt()</code> and <code>nextAt()</code> methods are used to
traverse an adjacency list of a graph, while <code>g.mate(u,e)</code>
returns the endpoint of edge <code>e</code> that is not <code>u</code>.
<p>
There is a simple web application that allows you to examine the
code for any of the provided modules and run the code in a browser.
<p>
<div  style="text-align:center;">
<img width="800" src="figs/grafalgoApp.png"><br>
</div>
<p>
When the app is first opened, the top text area is available
as a scratch pad that you can use to enter and run programs.
To run the <code>components</code> module first enter the following text
in the top window.
<pre style="padding-left:5%">
let g = new Graph();
g.fromString('{a[b d e] b[a c f] c[b d f] d[a c e] e[a d] f[b c] ' +
             'g[h] h[g i] i[h]}');
log(g);
let [ count, comps ] = components(g)
log(count + ' ' + comps);
</pre>
The <code>fromString</code> method initializes the graph object <code>g</code>
from a string, which specifies the graph as a set of adjacency
lists.
So for example, the initial portion of the provided argument,
(<code>a[b d e]</code>) specifies edges from <code>a</code>
to <code>b</code>, <code>d</code> and <code>e</code>.
The <code>log()</code> method can be viewed as a shorthand for
<code>console.log()</code>. Its output appears in the bottom window.
If you click on the <i>run</i> button at right, the following text
will appear in the lower window.
<pre style="padding-left:5%">
{a[b d e] b[a c f] c[b d f] d[a c e] e[a d] f[b c] g[h] h[g i] i[h]} 
2 {[a b c d e f][g h i]} 
</pre>
The first line shows the graph as a string.
The second shows the number of components and the vertices in each component.
<p>
If you replace the last three lines in the top window with
<pre style="padding-left:5%">
let [,,ts] = components(g,1)
log(ts);
</pre>
and click on the <i>run</i> button agin, you will get
<p>
<textarea rows="13" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
{a[b d e] b[a c f] c[b d f] d[a c e] e[a d] f[b c] g[h] h[g i] i[h]}
selected vertex, queue, components
a [b d e] {[a b d e]}
b [d e c f] {[a b d e c f]}
d [e c f] {[a b d e c f]}
e [c f] {[a b d e c f]}
c [f] {[a b d e c f]}
f [] {[a b d e c f]}
g [h] {[a b d e c f][g h]}
h [i] {[a b d e c f][g h i]}
i [] {[a b d e c f][g h i]}
</textarea>
<p>
The menus at the top right provide access to all the available code
modules. The first two menus list the data structures
and unit tests for each.
The next two list the algorithms that use those data structures,
along with their unit tests.
When a unit test is displayed, you can run it using the <code>run</code> button.
The last menu provides access to some common code modules.
You can <i>activate</i> a menu by clicking on the button to its
left, causing the selected item to be displayed.
Selecting an item from a different menu activates that menu.
Go back to the scratch pad by clicking on its button.
<p>
If you load the unit test for the components module,
you can run it by clicking on the <i>run</i> button,
The lines
<pre style="padding-left:5%">
let [k, dl, ts] = components(g,1);
assert(k, 3, 'a1');
assert(dl, '[(a b c d e f), (g h i)]', 'a2');
</pre>
run the <code>components</code> function and verify its output.
The <code>assert</code> function verifies that its first two
arguments are equal and prints an error message if they are not.
The error message includes string versions of the
first two arguments so that you can
see why the <code>assert</code> failed.
The third argument is a tag that appears in the error message so
you can more easily identify which call to
<code>assert</code> triggered a given message.
If <code>assert</code> is called with just two argments, the first
is assumed to be a boolean expression.
A failed call to <code>assert</code> also triggers an exception
which terminates the test.
For example, if you change the 2 in the first <code>assert</code>
statement to 3, you will get the message
<pre style="padding-left:5%">
AssertError: a1 2 3 
</pre>
<p>
If you spend some time reviewing the code for the <code>List</code>
module, you will be able to see for yourself of how it is implemented.
You will also see some features that are common to most of the data
structures in this collection.
For example, most have <code>toString</code>, <code>fromString</code>
and <code>equals</code> methods.
<p>
The application, is available at
<pre style="padding-left:5%">
www.cse.wustl.edu/~jon.turner/grafalgo/js
</pre>
The provided code is also available as part of the <i>Grafalgo</i>
library, which can be downloaded from
<pre style="padding-left:5%">
https://github.com/jonturner53/grafalgo
</pre>
The library includes <i>C</i>++ implementations of most of the code described
here, in addition to the <i>javascript</i> version.
The <i>C</i>++ version pre-dates the <i>javascript</i> version.
Do not expect them to fully consistent.
There is also the beginnings of a <i>java</i> version, which may (or may not)
be completed at some point.

<h2>Common Methods</h2>
All the provided data structure have a common super-class <code>Top</code>,
which defines an index range $1\ldots n$ for some integer $n$ and provides
the methods listed below.
<ul>
<li> <code>constructor(n=5)</code> constructs an object with an index range
    of <code>n</code>.
<li> <code>n</code> returns the index range of the object.
<li> <code>valid(i)</code> returns true if <code>i</code> is a valid
    index (that is, falls within the index range, or is zero).
<li> <code>reset(..)</code> constructs a new object passing the provided
    arguments to its constructor and transfers the contents of the
    constructed object to <code>this</code> object.
<li> <code>expand(n)</code> is a default version of a method used to
    expand the index range of an object and if necessary, the storage
    space associated with it. 
<li> <code>equals(other)</code> returns true if <code>this</code> object
    is equal to the argument <code>other</code>. Most classes define their
    own version of this method, but a default is provided, which handles
    some common cases. Specifically, if <code>other</code> is a string
    and <code>this</code> does not have a <code>fromString</code> method,
    the provided string is compared to the string representation of
    this object and a value of true or false is returned based on the string
    comparison. If <code>this</code> does define a <code>fromString</code>
    method, <code>other</code> is replaced with a new object which is
    initialized using <code>fromString</code>. If <code>other</code>
    is not a string and not an instance of the same class as <code>this</code>,
    or its index range is different, false is returned. In all other cases,
    a reference to <code>other</code> is returned. This can be used
    to complete the equality comparison.
<li> <code>index2string(i, label)</code> creates a string
    representation of the index $i$. <code>Label(i)</code> is an optional
    function argument.
    If present, it is used to generate the string.
    The default label function uses a lower-case letter in place of the integer
    index value, whenever the index range is $\leq 26$.
    To force numeric values in all cases, use
    <code>index2string(i, x => x)</code>. To use a string from an array
    of tags, use<code>index2string(i, x => tag[x])</code>.
    <code>index2string</code> can be abbreviated <code>x2s</code>.
<li> <code>ilist2string(l, label)</code> creates a string representation
    of a list of index values. Argument <code>l</code> is a one-dimensional
    array of index values for the object. The <code>label</code> argument
    is the same is in <code>index2string(i)</code>.
<li> <code>toString()</code> is a dummy method which every sub-class
    instantiates. It returns a string representation of the object.
    Most also support a format argument that can be used to specify
    various formatting options.
    Many also include a function argument <code>label(i)</code> that
    returns an alternate string to display for an item with index <i>i</i>.
</ul>
Most classes also define the following methods.
<ul>
<li> <code>fromString(s)</code> instantiates an object based on the
    string <code>s</code>.
<li> <code>assign(x)</code> assigns the value of object <code>x</code> to
    <code>this</code> by copying its contents.
<li> <code>xfer(x)</code> assigns the value of object <code>x</code> to
    <code>this</code> by transferring its contents.
    This effectively destroys <code>x</code>.
<li> <code>clear()</code> clears the value of the object (so for example,
    in the case of a list, the list becomes empty).
<li> <code>getStats()</code> returns a statistics object that contains
    one or more counters that count events of interest for a particular
    data structure. This method is typically defined only for classes
    that have operations that take more than constant time.
<li> <code>clearStats()</code> sets an object's statistic counters to zero.
</ul>

<a id=list><h2>List</h2></a>
The <code>List</code> class defines a list of distinct integers in
a limited range $1\ldots n$ and supports the following methods.
<ul>
<li> <code>constructor(n, cap=n)</code> constructs a <code>List</code> object
    with an index range of <code>n</code> and capacity of <code>cap</code>.
    Both arguments may be omitted.
    Initially, the list is empty.
<li> <code>first()</code> returns the first item on the list, or 0 if the list
    is empty.
<li> <code>last()</code> returns the last item on the list, or 0 if the list
    is empty.
<li> <code>next(i)</code> returns the next item in the list following
    <code>i</code> or 0 if <code>i</code> is the last item on the list.
<li> <code>length</code> returns the number of items in the list.
<li> <code>empty()</code> returns true if the list is empty, else false.
<li> <code>at(i)</code> returns the item at position <code>i</code>
    in the list, or 0 if there is no such item.
<li> <code>contains(i)</code> returns true if the list contains <code>i</code>,
    else false.
<li> <code>insert(i, j)</code> inserts item <code>i</code> after item
    <code>j</code>. If <code>j</code> is zero, <code>i</code> is inserted
    before the first item in the list.
<li> <code>deleteNext(i)</code> removes the item following <code>i</code>;
    if <code>i</code> is zero, it deletes the first item;
    the deleted item is returned.
<li> <code>push(i)</code> is an alias for <code>insert(i, 0)</code>.
<li> <code>pop()</code> is an alias for <code>deleteNext(0)</code>.
<li> <code>top()</code> is an alias for <code>first()</code>.
<li> <code>enq(i)</code> is an alias for <code>insert(i, last())</code>.
<li> <code>deq()</code> is an alias for <code>deleteNext(0)</code>.
<li> <code>setEquals(a)</code> is similar to <code>equals</code>,
    but returns true if <code>this</code> object
    contains the same list items as <code>a</code>, but not necessarily
    in the same order.
</ul>
When first constructed, a <code>List</code> uses a single <code>next</code>
array, linking successive list items; items not on the list have 
<code>next</code> values of $-1$, enabling a constant time
membership test. A <code>List</code> can be extended dynamically
to include a separate <code>prev</code> array, using the method
<code>addPrev()</code>, coverting it to a doubly linked list
that can be traversed in both directions.
With this addition, a <code>List</code> can
support the following additional methods.
<ul>
<li> <code>prev(i)</code> returns the item the precedes <code>i</code>
on the list.
<li> <code>delete(i)</code> removes an arbitrary list item.
<li> <code>popLast()</code> removes the last list item.
</ul>
In addition, the <code>at()</code> method of the extended <code>List</code>
object supports negative arguments, specifiying items relative to the
end of the list.
One can extend a <code>List</code> implicitly, simply by using one of
the methods that requires a doubly linked list.
<p>
The <code>List</code> object can also be extended to associate a set
of <i>values</i> with the list items, using the method <code>addValues</code>.
This enables the following methods.
<ul>
<li> <code>setValue(i, v)</code> sets the value of item <code>i</code> to
<code>v</code>.
<li> <code>value(i)</code> returns the value of item <code>i</code>.
</ul>
The assigned values are often simply numbers, but may be strings, arrays
or objects.
This extension can be enabled implicitly, by simply using the
<code>setValue()</code> method.
The core methods for the <code>List</code> class are shown below.
<p>
<textarea rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
import Top from '../Top.mjs';
import { assert, fassert } from '../../common/Errors.mjs';
import Scanner from './Scanner.mjs';

export default class List extends Top {
    #first;     // first item in list
    #last;      // last item in list
    #length;    // number of items in list
    #next;      // #next[i] is successor of i in list
    #prev;      // #prev[i] is predecessor of i in list
                // allocated dynamically as required
    #value;     // allocated dynamically as required
    
    /** Constructor for List object.
     *  @param n is the range for the list
     *  @param capacity is the max storage capacity
     */
    constructor(n=10, capacity=n) {
        super(n);
        this.#next = new Int32Array(capacity+1).fill(-1);
        this.#next[0] = this.#first = this.#last = this.#length = 0;
        this.#prev = this.#value = null;
    }

    /** Convert to a doubly-linked list. */
    addPrev() {
        if (this.hasPrev) return;
        this.#prev = new Int32Array(this.capacity+1);
        for (let i = this.first(); i; i = this.next(i))
            if (this.next(i)) this.#prev[this.next(i)] = i;
    }

    /** Determine if this object is doubly-linked. */
    get hasPrev() { return this.#prev ? true : false; }

    /** Add a value for each list item */
    addValues() {
        if (this.hasValues) return;
        this.#value = new Array(this.#next.length).fill(null);
    }

    /** Determine if this object includes item values. */
    get hasValues() { return this.#value ? true : false; }

    /** Get the value of an item.
     *  @param i is an integer
     *  @param val is an optional value to be assigned to i
     *  @return the value of i or null if i is not a valid item or no
     *  value has been assigned to it
     */
    value(i, val=null) {
        if (val != null) {
            if (!this.hasValues) this.addValues();
            this.#value[i] = val;
        }
        return (this.valid(i) && this.hasValues ? this.#value[i] : null);
    }

    /** Assign new value to list from another. 
     *  @paran l is a list whose value is to be assigned to this
     */
    assign(l) {
        fassert(l instanceof List);
        if (l == this) return;
        if (l.n > this.capacity) this.reset(l.n);
        else { this.clear(); this._n = l.n; }
        if (l.hasPrev && !this.hasPrev) this.addPrev();
        if (l.hasValues && !this.hasValues) this.addValues();
        if (this.hasValues) {
            for (let i = 0; i <= this.n; i++) this.value(i,l.value(i));
        }
        for (let i = l.first(); i != 0; i = l.next(i)) {
            if (this.hasValues) this.enq(i, l.value(i));
            else this.enq(i);
        }
    }

    /** Assign a new value to this, by transferring contents of another list.
     *  @param l is a list whose contents are to be transferred to this
     */
    xfer(l) {
        fassert(l instanceof List);
        if (l == this) return;
        this._n = l.n;
        this.#first = l.first(); this.#last = l.last();
        this.#length = l.length;
        this.#next = l.#next; l.#next = null;
        this.#prev = l.#prev; l.#prev = null;
        this.#value = l.#value; l.#value = null;
    }
    
    /** Remove all elements from list. */
    clear() { while (!this.empty()) this.pop(); }

    /** Get the number of items in the list. */
    get length() { return this.#length; }

    /** Get the capacity of the list (max number of items it has space for). */
    get capacity() { return this.#next.length - 1; }
    
    /** Get the next item in a list.
     *  @param i is an item on the list
     *  @return the item that follows i, or 0 if there is no next item
     */
    next(i) { return this.#next[i]; }
    
    /** Get the previous item in a list.
     *  @param i is an item on the list
     *  @return the item that follows i, or 0 if there is no next item
     */
    prev(i) {
        if (!this.#prev) this.addPrev();
        return this.#prev[i];
    }
    
    /** Get first item on list.
     *  @return the first item on the list or 0 if the list is empty
     */
    first() { return this.#first; }
    top() { return this.#first; }
    
    /** Get the last item on list.
     *  @return the last item on the list or 0 if the list is empty
     */
    last() { return this.#last; }

    /** Get an item based on its position in the list.
     *  @param i is position of index to be returned; negative
     *  values are interpreted from end of list (so, at(-1) == last())
     *  @return item at position i, or 0 if no such item
     */
    at(i) {
        if (i > 0) {
            for (let j = this.first(); j != 0; j = this.next(j)) {
                if (--i == 0) return j;
            }
        } else if (i < 0) {
            if (!this.#prev) this.addPrev();
            for (let j = this.last(); j != 0; j = this.prev(j)) {
                if (++i == 0) return j;
            }
        }
        return 0;
    }
    
    /** Test if list is empty.
     *  @return true if list is empty, else false.
     */
    empty() { return this.length == 0; }
    
    /** Test if an item is in the list. 
     *  @param i is an item
     *  @return true if i is in the list, else false
     */
    contains(i) { return this.valid(i) && i != 0 && this.#next[i] != -1; } 

    /** Insert an item into the list, relative to another. 
     *  @param i is item to insert
     *  @param j is item after which i is to be inserted;
     *  @param value is optional value for inserted item
     *  if zero, i is inserted at the front of the list
     */
    insert(i, j, value=null) {
        if (i > this.n) this.expand(i);
        fassert(this.valid(i) && i != 0 && !this.contains(i) &&
                       (j == 0 || this.contains(j)),
                `List.enq: ${this.x2s(i)} ${this.x2s(j)} ${this.toString()}`);
        if (value != null) this.value(i, value);
        if (j == 0) {
            if (this.empty()) this.#last = i;
            this.#next[i] = this.#first; this.#first = i; this.#length++;
        } else {
            this.#next[i] = this.#next[j]; this.#next[j] = i; this.#length++;
            if (this.#last == j) this.#last = i;
        }
        if (this.#prev) {
            this.#prev[i] = j;
            if (i != this.last()) this.#prev[this.next(i)] = i;
        }
        return;
    }
    
    /** Remove the item following a specified item. 
     *  @param i is item whose successor is to be deleted;
     *  if zero, the first item is deleted
     *  @return the item that follows the deleted item
     */
    deleteNext(i) {
        fassert(i == 0 || this.contains(i));
        if (i == this.last()) return 0;
        let j;
        if (i == 0) { j = this.#first;   this.#first = this.#next[j]; }
        else        { j = this.#next[i]; this.#next[i] = this.#next[j]; }
        if (this.#last == j) this.#last = i;
        this.#next[j] = -1; this.#length--;
        if (this.#prev) {
            if (i == 0)
                this.#prev[this.first()] = 0;
            else if (this.next(i) != 0)
                this.#prev[this.next(i)] = i;
            this.#prev[j] = 0;
        }
        if (this.hasValues) this.value(j,null);
        return (i == 0 ? this.first() : this.next(i));
    }

    /** Remove a specified item.
     *  @param i is an item to be removed
     *  @return item that follows i
     */
    delete(i) {
        fassert(this.valid(i));
        if (!this.contains(i)) return;
        return (i == this.first() ? this.deleteNext(0) :
                                    this.deleteNext(this.prev(i)));
    }
    
    /** Push item onto front of a list. 
     *  @param item to be added.
     *  @param value is an optional value associated with i
     */
    push(i, value) { this.insert(i, 0, value); }
    
    /** Remove the first item in the list. 
     *  @return the item removed, or 0
     */
    pop() { let i = this.first(); this.deleteNext(0); return i; }

    /** Remove the last item on the list.
     *  @return true if the list was modified, else false
     */
    popLast() { this.delete(this.last()); }
    
    /** Add item to the end of the list. 
     *  @param item to be added.
     *  @param value is an optional value associated with i
     *  @return true if the list was modified, else false
     */
    enq(i, value) { this.insert(i, this.last(), value); }
    
    /** Remove the first item in the list. 
     *  @return the item removed, or 0
     */
    deq() { return this.pop(); }
}
</textarea>

<a id=listPair><h2>ListPair</h2></a>
The <code>ListPair</code> class defines two complementary lists over
the same index range. One is referred to as <code>list 1</code>,
the other as <code>list 2</code>.
<ul>
<li> <code>constructor(n, cap=n)</code> constructs a <code>ListPair</code>
    object with an index range of <code>n</code> and capacity of
    <code>cap</code>. Both arguments may be omitted.
    Initially, all items are in <code>list 2</code>.
<li> <code>in1(i)</code> returns true if <code>i</code> is in
    list 1.
<li> <code>in2(i)</code> returns true if <code>i</code> is in
    list 2.
<li> <code>first1()</code> returns the first item in
    list 1 or 0 if the list is empty.
<li> <code>first2()</code> returns the first item in
    list 2 or 0 if the list is empty.
<li> <code>last1()</code> returns the last item in
    list 1 or 0 if the list is empty.
<li> <code>last2()</code> returns the last item in
    list 2 or 0 if the list is empty.
<li> <code>next1(i)</code> returns the next item in
    list 1 following <code>i</code> or 0 if <code>i</code> is the last item.
<li> <code>next2(i)</code> returns the next item in
    list 2 following <code>i</code> or 0 if <code>i</code> is the last item.
<li> <code>prev1(i)</code> returns the previous item in
    list 1 following <code>i</code> or 0 if <code>i</code> is the first item.
<li> <code>prev2(i)</code> returns the previous item in
    list 2 following <code>i</code> or 0 if <code>i</code> is the first item.
<li> <code>swap(i)</code> transfers <code>i</code> from its current list to
    the other.
</ul>
<code>ListPair</code> implements both lists using shared <code>next</code>
and <code>prev</code> arrays. For items in list 2, the
<code>prev</code> values are negative integers.
All operations listed above take constant time.
The core methods for the <code>ListPair</code> class are shown below.
<p>
<textarea rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class ListPair extends Top {
    #n1;        // number of items in list 1
    #n2;        // number of items in list 2

    #first1;    // first item in the list 1
    #last1;     // last item in the list 1
    #first2;    // first item in the list 2
    #last2      // last item in the list 2
    #next;      // #next[i] defines next item after i
                // in items use positive #next values
                // out items use negative #next values
    #prev;      // #prev[i] defines item preceding i
                // in items use positive #prev values
                // out items use negative #prev values
    
    /** Constructor for list pair.
     *  @param n specifies the range of integer values
     *  @param capacity specifies the maximum range to provide space for
     */
    constructor(n=10, capacity=n) {
        super(n);
        this.#next = new Int32Array(capacity+1);
        this.#prev = new Int32Array(capacity+1);
        this.#first1 = this.#last1 = 0;
        this.#first2 = 1; this.#last2 = this.n;
        for (let i = 1; i <= capacity; i++) {
            this.#next[i] = i+1; this.#prev[i] = -(i-1);
        }
        this.#next[this.n] = this.#prev[1] = 0;
        this.#n1 = 0; this.#n2 = this.n;
    }

    /** Determine if an item belongs to list 1
     *  @param i is a valid list item
     *  @param return true if i is a member of the list 1, else false.
     */
    in1(i) {
        fassert(this.valid(i), `ListPair.in1: invalid item ${i} (n=${this.n})`);
        return this.#prev[i] > 0 || i == this.#first1;
    }
    
    /** Determine if an int belongs to the list 2.
     *  @param i is a valid list item
     *  @param return true if i is a member of the list 2, else false.
     */
    in2(i) {
        fassert(this.valid(i), `ListPair.in2: invalid item ${i} (n=${this.n})`);
        return this.#prev[i] < 0 || i == this.#first2;
    }
    
    /** Get the number of elements in list 1.  */
    n1() { return this.#n1; }
    
    /** Get the number of elements in list 2  */
    n2() { return this.#n2; }
    
    /** Get the first item in list 1.
     *  @return the first value on the list 1 or 0 if the list is empty.
     */
    first1() { return this.#first1; }
    
    /** Get the first item in list 2.
     *  @return the first value on the list 2 or 0 if the list is empty.
     */
    first2() { return this.#first2; }
    
    /** Get the last item in list 1.
     *  @return the last value on the list 1 or 0 if the list is empty.
     */
    last1() { return this.#last1; }
    
    /** Get the first item in list 2.
     *  @return the last value on the list 2 or 0 if the list is empty.
     */
    last2() { return this.#last2; }
    
    /** Get the next item in list 1.
     *  @param i is the "current" value
     *  @return the next int on the list 1 or 0 if no more values
     */
    next1(i) {
        fassert(this.in1(i), `ListPair.next: item ${i} not in list1`);
        return this.#next[i];
    }
    
    /** Get the next value in the list2.
     *  @param i is the "current" value
     *  @return the next value on the list 2 or 0 if no more values
     */
    next2(i) {
        fassert(this.in2(i)); return this.#next[i];
    }
    
    /** Get the previous value in list 1.
     *  @param i is the "current" value
     *  @return the previous value on the list 1 or 0 if no more values
     */
    prev1(i) {
        fassert(this.in1(i)); return this.#prev[i];
    }
    
    /** Get the previous value in list 2.
     *  @param i is the "current" value
     *  @return the previous value on the list 2 or 0 if no more values
     */
    prev2(i) {
        fassert(this.in2(i)); return -this.#prev[i];
    }
    
    /** Remove all elements from list 1. */
    clear() { while (this.first1() != 0) this.swap(this.first1()); }
    
    /** Move an item from one list to the other.
     *  Inserts swapped item at end of the other list
     *  @param i is the index of item to be swapped
     *  @param j is a list item in the "other" list; i is inserted
     *  into the other list, following item j, or at the start if j=0.
     */
    swap(i, j=-1) {
        if (j < 0) j = this.in1(i) ? this.last2() : this.last1();

        fassert(this.valid(i) && i != 0 && this.valid(j));
        fassert((this.in1(i)  && (j == 0 || this.in2(j))) ||
               (this.in2(i) && (j == 0 || this.in1(j))));

        if (this.in1(i)) {
            // first remove i from list 1
            if (i == this.last1()) this.#last1 = this.#prev[i];
            else this.#prev[this.#next[i]] = this.#prev[i];
            if (i == this.first1()) this.#first1 = this.#next[i];
            else this.#next[this.#prev[i]] = this.#next[i];
    
            // now add i to list 2
            if (this.#n2 == 0) {
                this.#next[i] = this.#prev[i] = 0;
                this.#first2 = this.#last2 = i;
            } else if (j == 0) {
                this.#next[i] = this.#first2; this.#prev[i] = 0;
                this.#prev[this.#first2] = -i; this.#first2 = i;
            } else if (j == this.#last2) {
                this.#next[j] = i; this.#prev[i] = -j;
                this.#next[i] = 0; this.#last2 = i;
            } else {
                this.#next[i] = this.#next[j]; this.#prev[i] = -j; 
                this.#prev[this.#next[j]] = -i; this.#next[j] = i;
            }
            this.#n1--; this.#n2++;
        } else {
            // first remove i from list 2
            if (i == this.last2()) this.#last2 = -this.#prev[i];
            else this.#prev[this.#next[i]] = this.#prev[i];
            if (i == this.first2()) this.#first2 = this.#next[i];
            else this.#next[-this.#prev[i]] = this.#next[i];
    
            // now add i to list 1
            if (this.#n1 == 0) {
                this.#next[i] = this.#prev[i] = 0;
                this.#first1 = this.#last1 = i;
            } else if (j == 0) {
                this.#next[i] = this.#first1; this.#prev[i] = 0;
                this.#prev[this.#first1] = i; this.#first1 = i;
            } else if (j == this.#last1) {
                this.#next[j] = i; this.#prev[i] = j;
                this.#next[i] = 0; this.#last1 = i;
            } else {
                this.#next[i] = this.#next[j]; this.#prev[i] = j; 
                this.#prev[this.#next[j]] = i; this.#next[j] = i;
            }
            this.#n1++; this.#n2--;
        }
        return;
    }
}
</textarea>
<p>

<a id=dlists><h2>ListSet</h2></a>
The <code>ListSet</code> class implements a collection of disjoint
lists on a common index set $1\ldots n$.
Each list in the collection is identified by its first list item.
The primary methods are listed below.
<ul>
<li>    <code>isFirst(i)</code> returns true if item <code>i</code> is
        the first item in some list.
<li>    <code>singleton(i)</code> returns true if item <code>i</code> is
        the only item in its list.
<li>    <code>last(i)</code> is the last item in the list identified by
        <code>i</code> (that is, <code>i</code> is the first list item).
<li>    <code>next(i)</code> is the next item on the list containing
        <code>i</code> or 0 if <code>i</code> is the last item.
<li>    <code>prev(i)</code> is the previous item on the list containing
        <code>i</code> or 0 if <code>i</code> is the first item.
<li>    <code>findList(i)</code> returns the first item in the list containing
        <code>i</code>.
<li>    <code>rotate(f, i)</code> rotates the list identfied by <code>f</code>
        to make <code>i</code> the first list item. That is, the portion
        of the list that precedes <code>i</code> is moved to the end of
        the list. It returns <code>i</code>.
<li>    <code>delete(i, f)</code> removes <code>i</code> from the list
        identified by <code>f</code>. The identifier of the
        modified list is returned.
<li>    <code>join(f1, f2)</code> combine the lists identified by 
        <code>f1</code> and <code>f2</code> and return the identifier of
        the new list. The new list is the concatenation of the two lists.
        If either argument is 0, the other is returned.
<li>    <code>sort(compare=0)</code> sorts the items on all lists;
        <code>compare(a,b)</code> is an optional comparison function,
        that returns $-1$ if <code>a</code> should precede <code>b</code>
        in the list, $+1$ if <code>a</code> should follow <code>b</code>
        and 0 otherwise; the default function is <code>(a,b)=>a-b</code>.
<li>    <code>setEquals(other)</code> is similar to <code>equals</code>
        but compares the two objects based on set equality,
        rather than list equality.
</ul>
<code>ListSet</code> is implemented using shared <code>next</code> and
<code>prev</code> arrays.
The <code>findList(i)</code> method takes time proportional to the
position of item <code>i</code> in the list and the <code>sort</code>
method takes $O(n \log n)$ time. All others listed above take
constant time.
The core methods for the <code>ListSet</code> class are shown below.
<p>
<textarea rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class ListSet extends Top {
    #next;      // #next[i] is next item on list or 0 for last item
    #prev;      // #prev[i] is previous item on list or last for first item,
                // where last is the last item on the list

    constructor(n=10, capacity=n) {
        super(n);
        this.#next = new Int32Array(capacity+1);
        this.#prev = new Int32Array(capacity+1);
        // initialize to singleton lists
        this.#next.fill(0);
        for (let i = 0; i <= this.capacity; i++) this.#prev[i] = i;
    }
    
    /** Clear the data structure, moving all items into single node lists.
    */
    clear() {
        for (let i = 1; i <= this.n; i++) {
            this.#next[i] = 0; this.#prev[i] = i;
        }
    }

    isfirst(i) {
        fassert(this.valid(i)); return this.#next[this.#prev[i]] == 0;
    }
    
    /** Get the last item in a list.
     *  @param f is the first item on a list.
     *  @return the last item in the list
     */
    last(f) {
        fassert(this.isfirst(f));
        return this.#prev[f];
    }

    /** Get the next list item.
     *  @param i is a list item
     *  @return the item that follows i in its list
     */
    next(i) {
        fassert(this.valid(i)); return this.#next[i];
    }
    
    /** Get the previous list item.
     *  @param i is a list item
     *  @return the item that precedes i in its list
     */
    prev(i) {
        return (this.isfirst(i) ? 0 : this.#prev[i]);
    }

    /** Find the first item in a list. */
    find(i) {
        while (this.prev(i)) i = this.prev(i);
        return i;
    }

    /** Determine if an item is in a singleton list.
     *  @param i is the index of an item
     *  @return true if it is the only item in its list, else false
     */
    singleton(i) {
        fassert(this.valid(i));
        return this.#prev[i] == i;
    }
    
    /** Find the start of a list.
     *  @param i is an item on some list
     *  @return the first item on the list
     */
    findList(i) {
        fassert(this.valid(i));
        while (this.prev(i) != 0) i = this.prev(i);
        return i;
    }

    /** Rotate list to make i it's first item.
     *  @param f is the first item on a list.
     *  @param i is another item on the same list
     *  @return the modified list
     */
    rotate(f, i) {
        if (i == f) return i;
        this.#next[this.last(f)] = f;
        this.#prev[f] = this.#prev[f];
        this.#next[this.#prev[i]] = 0;
        return i;
    }
    
    /** Remove an item from its list.
     *  This method turns the deleted item into a singleton list.
     *  @param i is an item in a list
     *  @param f is the first item of a list
     *  @return the first item of the modified list, or 0 if f was a singleton
     */
    delete(i, f) {
        fassert(this.valid(i) && this.valid(f) && this.isfirst(f));
        if (this.singleton(f)) return 0;
        let l = this.last(f); let nf = this.next(f);
        let pi = this.prev(i); let ni = this.next(i);
        if (i == f) {
            this.#prev[nf] = this.#prev[f]; f = nf;
        } else if (i == l) {
            this.#prev[f] = pi; this.#next[pi] = 0;
        } else {
            this.#prev[ni] = pi; this.#next[pi] = ni;
        }
        this.#next[i] = 0; this.#prev[i] = i;
        return f;
    }
    
    /** Join two lists together.
     *  @param f1 is the first item on a list
     *  @param f2 is the first item on another list
     *  @return the id of the list formed by joining the two lists;
     *  defined to be f1, for non-zero f1
     */
    join(f1, f2) {
        fassert(this.valid(f1) && this.valid(f2));
        if (f2 == 0 || f1 == f2) return f1;
        if (f1 == 0) return f2;
        let l1 = this.last(f1); let l2 = this.last(f2);
        this.#next[l1] = f2;
        this.#prev[f2] = l1;
        this.#prev[f1] = l2
        return f1;
    }

    /** Split a list at an item. */
    split(f, i) {
        fassert (this.valid(f) && this.valid(i) && this.isfirst(f));
        if (i == 0 || i == f) return;
        let p = this.prev(i); let s = this.next(i);
        this.#next[p] = s; this.#prev[s] = p;
        this.#next[i] = 0; this.#prev[i] = i;
    }

    /** Sort the lists in ascending order.
     *  @param cmp(a,b) is an optional comparison funcion used to compare two
     *  items; it returns -1 if a<b, 0 if a=b and +1 if a>b. If no comparison
     *  function is provided, the function (a,b) => a-b is used.
     */
    sort(cmp=0) {
        if (!cmp) cmp = ((a,b) => a-b);
        let vec = [];
        for (let i = 1; i <= this.n; i++) {
            if (this.singleton(i) || !this.isfirst(i)) continue;
            let j = i; vec.length = 0;
            while (!this.singleton(j)) {
                vec.push(j); j = this.delete(j, j);
            }
            vec.push(j);
            vec.sort(cmp);
            for (j = 1; j < vec.length; j++)
                this.join(vec[0], vec[j])
        }
    }

    /** Determine if two ListSets define the same sets.
     *  @param other is a second ListSet or a string representing a
     *  ListSet object
     *  @return true if the two ListSet objects define identical sets.
     */
    setEquals(other) {
        let ls = super.equals(other);
        if (typeof ls == 'boolean') return ls;
        let l = new List(this.n);
        for (let i = 1; i < this.n; i++) {
            if (!this.isfirst(i)) continue;
            l.clear();
            for (let j = i; j; j = this.next(j)) l.enq(j);
            let lng = 0;
            for (let j = ls.find(i); j; j = ls.next(j)) {
                if (!l.contains(j)) return false;
                lng++;
            }
            if (lng != l.length) return false;
        }
        return ls;
    }
}
</textarea>
<h2>ReverseLists</h2>
<p>
The <code>ReverseLists</code> class is similar to <code>ListSet</code> in
that it partitions the index range into a set of lists. The distinctive
feature of the <code>ReverseLists</code> class is that its lists can
be <i>reversed</i> in constant time.
The new methods are listed below.
<ul>
<li>    <code>reverse(f)</code> reverses the list identified by <code>f</code>.
        Returns the first item in the reversed list.
<li>    <code>next(i, j)</code> returns the next item on the list containing
        <code>i</code>, assuming that
        <code>j</code> is the item just before <code>i</code>.
        If <code>i</code> is the first item, <code>j</code> must be 0.
        If there is no item following <code>i</code>, 0 is returned.
<li>    <code>prev(i, j)</code> returns the previous item on the list containing
        <code>i</code>, assuming that
        <code>j</code> is the item that follows <code>i</code>.
        If <code>i</code> is the last item, <code>j</code> must be 0.
        If there is no item preceiding <code>i</code>, 0 is returned.
</ul>
<code>ReverseLists</code> replaces the <code>next</code> and <code>prev</code>
arrays of the <code>ListSet</code> class, with arrays that represent
neighboring list items, <code>nabor1</code> and <code>nabor2</code>.
A list is reversed by effectively complementing a bit that determines which
of two neighbors of the first item is the next item on the list and which is
the last item. With this information, one can traverse the list in
either direction using a &ldquo;trailing pointer.&rdquo;
In the <i>Javascript</i> implementation, the first list item uses a
positive value for the <code>nabor</code> that identifies the next list item
and a negative value for the other <code>nabor</code>.
<p>
<textarea rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
/** Get the next list item.
 *  @param i is a list item
 *  @param j is the list item preceding i, or 0 if i is the first item.
 *  @return the pair [next(i), i] where next(i) is next list item or 0.
 */
next(i, j) {
    fassert(this.valid(i) && i != 0 && this.valid(j));
    let n1 = this.#nabor1[i]; let n2 = this.#nabor2[i];
    return [j == 0 ? (n1 >= 0 ? n1 : n2) :
                     (j == n1 ? n2 : n1), i];
}
   
/** Get the previous list item.
 *  @param i is a list item
 *  @param j is the list item following i, or 0 if i is the last item.
 *  @return the item that precedes j on the list, or 0 if j is the first
 *  item.
 */
prev(i, j) {
    fassert(this.valid(i));
    if (this.isFirst(i)) return [0, i];
    let n1 = this.#nabor1[i]; let n2 = this.#nabor2[i];
    return [j == 0 ? (n1 != 0 ? n1 : n2) :
                     (j == n1 ? n2 : n1), i];
}

/** Reverse a list.
 *  @param f is the first item on a list
 *  @return the first item on the reversed list
 */
reverse(f) {
    if (this.singleton(f)) return f;
    let l = this.last(f);
    if (this.#nabor1[f] < 0)  this.#nabor1[f] = 0;
    else                      this.#nabor2[f] = 0;
    if (this.#nabor1[l] == 0) this.#nabor1[l] = -f;
    else                      this.#nabor2[l] = -f;
    return l
}
</textarea>

<a id=dsets><h2>MergeSets</h2></a>

The <code>MergeSets</code> class defines a collection of disjoint sets
over the index set $1\ldots n$ and provides methods to efficiently identify
the subset containing a given item and to combine subsets.
Each subset is identified by one of its members.
The key methods are listed below.
<ul>
<li> <code>find(i)</code> returns the item in the set containing
    <code>i</code> that serves as its identifier.
<li> <code>merge(i, j)</code> combines the two sets identified by
    items <code>i</code> and <code>j</code> and returns the item
    that identifies the combined set.
</ul>
Each subset in the <code>MergeSets</code> object is implemented as a tree,
defined using <i>parent pointers</i>. That is, $p(i)$ identifies the
parent of $i$ in its tree and the root of the tree serves as its
identfier. If $i$ is a root, $p(i)=i$.
This is illustrated below.
<p>
<div  style="text-align:center;">
<img width="500" src="figs/disjointSets.png"><br>
</div>
<p>
The <code>find</code> method follows parent pointers up the tree to
find the root and the <code>merge</code> operation combines two trees
by directing the parent pointer of one of the two tree roots to the other,
essentially making one tree a subtree of the other's root.
<p>
Two heuristics are used to make the data structure efficient.
The <i>merge-by-rank</i> heuristic defines a
property $rank(i)$ for each item $i$ and uses it when combining
trees to limit the depth of the trees.
Initially, the $rank$ values are 0 and when two trees are merged,
the parent pointer of the tree root with the smaller rank is directed 
to the other root. If the two roots have equal ranks, the rank of
the new root (chosen arbitrarily) is incremented.
This procedure ensures that the maximum depth of a node is
$\lg n$ and that the running time for the <code>find</code> method is
$O(\lg n)$.
<p>
The second heuristic is called <i>path compression</i> and is
implemented as part of the <code>find</code> method.
Specifically, after finding the root of a tree, the <code>find</code> method
makes a second pass over the path, redirecting all of the parent pointers
along the path, so that they point directly to the root.
This speeds up subsequent calls to <code>find</code> and ensures
that any sequence of calls to <code>find</code> and <code>merge</code> takes
essentially linear time. A detailed performance analysis is given in the
following subsection.
The core of the <i>Javascript</i> implementation is shown below.
<p>
<textarea rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class MergeSets extends Top {
    #p;            // #p[i] is parent of i
    #rank;         // #rank[i] is rank of i

    constructor(n=10, capacity=n) {
        super(n);
        this.#p = new Int32Array(capacity+1); 
        this.#rank = new Int32Array(capacity+1);
        this.clear();
    }
    
    /** Return parent of a set element in the tree representation of the set.
     *  @param i index of a set element
     *  @return the parent of i
     */
    p(i) { return this.#p[i]; }

    /** Return rank of a set element in the tree representation of the set.
     *  @param i index of a set element
     *  @return the parent of i
     */
    rank(i) { return this.#rank[i]; }
    
    /** Find and return the canonical element of a set.
     *  Performs path compression as side-effect.
     *  @param i is an index in some set
     *  @return the canonical element of the set containing i
     */
    find(i) {
        fassert(this.valid(i));
        let root;
        for (root = i; this.p(root) != root; root = this.p(root)) { }
        while (i != root) { let pi = this.p(i); this.#p[i] = root; i = pi; }
        return root;
    }
    
    /** Combine two sets.
     *  @param i is the canonical element of some set.
     *  @param j is the canonical element of another (distinct) set
     *  @return the canonical element of the set obtained by combining
     *  the given sets
     */
    merge(i, j) {
        fassert(this.valid(i) && this.valid(j) &&
               this.p(i) == i && this.p(j) == j && i != j);
        if (this.rank(i) < this.rank(j)) {
            let t = i; i = j; j = t;
        } else if (this.rank(i) == this.rank(j)) {
            this.#rank[i]++;
        }
        this.#p[j] = i;
        return i;
    }
}
</textarea>

<h3>Performance Analysis</h3>
(The analysis in this section is an expanded version of
the analysis in Chapter 2 of [Tarjan87].)
Although the disjoint sets data structure is very simple,
fully analyzing its performance is not.
To make it easier to understand, the analysis is presented in several steps,
with each successive step giving a tighter bound on the performance.

<h4>Basic Analysis</h4>

The initialization of the data structure takes $O(n)$ time
and the merge operation takes constant time. So, the only question
is how much time is required for the find operations?
This depends on the depth of the tree. We start by noting
that the merge-by-rank heuristic ensures that the rank of
any item is strictly less than the rank of its parent.
Consequently, $\textit{rank}(x)$ is
an upper bound on the height of $x$ in the tree.
So, if $x$ is a tree root, the time for a find operation
starting within $x$'s tree is at most $\textit{rank}(x)$.
So, an upper bound on $\textit{rank}(x)$, yields a
bound on the running time of the find operation.
The key to bounding $\textit{rank}(x)$ is to observe that
the number of nodes in $x$'s subtree is at least $2^{\textit{rank}(x)}$.
This can be proved by induction on the number of merge
operations, as illustrated below.
<p>
<div  style="text-align:center;">
<img width="600" src="figs/dsetsLemma.png"><br>
</div>
<p>
This implies that if a tree root has rank $k$,
then $2^k \leq n$ and so $k \leq \lg n$.
This implies an $O(\log n)$ bound on the time required for each find operation.
Note that this result does not depend on the path compression heuristic.
Also, note that some find operations can take time proportional to
$\log n$, so there can be no better bound on the time for an
arbitrary find operation.
However, it is possible to get a stronger bound on a
sequence of find operations, using a more sophisticated analysis
that takes into account the effects of path compression.

<h4>A  Better Analysis</h4>

As a first step in a more detailed analysis,
let's make a few observations about the ranks.
First, as noted earlier, the rank of a non-root node is strictly
less than the rank of its parent. Also, the rank of a node
can increase as a result of merge operations, but it can never decrease,
and once a node becomes a child of another node, its rank can no
longer change.
Finally, $rank(p(x))$ can increase (as a result of either merge
operations or find operations that change $p(x)$), but it can
never decrease. These observations are collected in the following lemma.
<p>
<i>Lemma 1</i>.
If $x$ is any node, $\textit{rank}(x) \leq rank(p(x))$ with the
inequality strict if $p(x) \neq x$.
The value of $\textit{rank}(x)$ is initially 0 and increases with
time until $p(x)$ is assigned a value other than $x$.
Subsequently, $\textit{rank}(x)$ does not change.
The value of $rank(p(x))$ is a nondecreasing function of time.
<p>
To facilitate the analysis, consider each find operation as
consisting of a series of <i>find steps</i>, one for each node
along the path followed by the operation.
The objective is to put an upper bound on the total number
of find steps.
Note that the number of find steps at root nodes is
equal to the number of find operations,
so the remaining analysis considers only find steps
at non-root nodes.
<p>
Define $\Delta(x)=rank(p(x)) - \textit{rank}(x)$ and note that
$\Delta(x) \leq \lg n$ and that
$\Delta(x)=0$ initially, and increases
as $x$ acquires a parent
and participates in find operations.
Also, define a node $x$ to be <i>dominant</i> if $\Delta(x)>2\Delta(y)$
for all proper ancestors $y$ of $x$.
<p>
The analysis can be split into two cases, one covering find steps
that occur at dominant nodes, and the other covering find steps that
occur at non-dominant nodes.
The analysis of the first case rests on the observation that there
can be at most $\lg \lg n$ dominant nodes along the path from 
any node to the root of its tree.
Consequently, each find operation can include at most $\lg \lg n$
find steps at dominant nodes.
Consequently, in a sequence of $m$ find operations,
at most $m\lg\lg n$ find steps occur at dominant nodes.
<p>
Proceeding to the second case, note that if $x$ is not dominant,
then $x$ must have some proper ancestor $y$ with
$\Delta(y) \geq \Delta(x)/2$.
This implies that $rank(p(y))-\textit{rank}(x) \geq 1.5 \times \textit{rank}(x)$
before the find.
After the find completes, $x$'s parent has rank at least as large the
original value of $rank(p(y))$.
Consequently, the find operation causes $\Delta(x)$ to increase
by a factor of at least 1.5.
This is illustrated below.

<p>
<div  style="text-align:center;">
<img width="600" src="figs/dsetsAnalysis1.png"><br>
</div>
<p>

Since every find step that occurs at $x$ at times when $x$ is not
dominant causes $\Delta(x)$ to increase by a factor of 1.5, there can be
no more than $2 \lg\lg n$ find steps at a node $x$
when it is not dominant. Consequently, the total number
of find steps at non-dominant nodes is $O(n \log\log n)$
and the total number of find steps is $O((m+n)\log\log n)$.

<h4>A Still Better Analysis</h4>

From a practical perspective, there is little reason
to carry the analysis further, since for any practical
value of $n$, $\lg \lg n$ is very small. However, it is
possible to do better and it's instructive to see how.
The new analysis requires some additional technical machinery.
Rather than go straight to the final analysis, let's
build up to it in several steps, with each step
providing some improvement on what has gone before.
The first step will show that the number of find steps
is at $O(m + n\log\log n)$.
<p>
Start by dividing the non-negative integers
into a series of <i>blocks</i> by defining $block(0)=[0,1]$,
$block(1)=[2,3]$, $block(2)=[4,5,6,7]$ and in general
for $j\geq 1$, $block(j)=[2^j,\ldots,2^{j+1}-1]$.
More simply, $block(j)$ can be written as the half-open
interval $\left[2^j,2^{j+1}\right)$.
A node $x$ is said to be <i>on level 1</i> if
there is some $block(j)$ that contains both
$\textit{rank}(x)$ and $rank(p(x))$.
All other nodes are on level 2.
Note that once a node becomes a level 2 node,
it can never again become a level 1 node
(since $\textit{rank}(x)$ does not change once $x$ acquires
a parent and $rank(p(x))$ never decreases).
In the example shown below,
nodes $a$ and $d$ are on level 1, while nodes
$b$ and $c$ are on level 2
A node is called <i>singular</i> if none of its proper ancestors
is on the same level as it is.
So in the example, $c$ and $d$ are singular.

<p>
<div  style="text-align:center;">
<img width="450" src="figs/dsetsAnalysis2.png"><br>
</div>
<p>

As before, the analysis divides into two cases.
The first counts the find steps that occur at singular nodes,
while the second counts the find steps that occur at non-singular nodes.
For the first case, note that any path from a node to the root of its
tree can contain at most one singular node on each of the two levels.
Hence, each find operation includes at most two find steps at singular nodes
and the total number of find steps at singular nodes is $O(m)$.
<p>
The find steps at non-singular nodes can be divided into two
sub-cases, one for the find steps involving level 1 nodes and another
for the find steps involving level 2 nodes.
Let's consider the second case first.
Suppose $x$ is a non-singular node on level 2.
Because $x$ is non-singular, it has some ancestor $y$ that is also
on level 2. Because $x$ is on level 2, $rank(p(x))$ is
in a different block than $\textit{rank}(x)$. Similarly,
$rank(p(y))$ is in a different block than $rank(y)$.
Consequently, if $z$ is the root of the tree, then
$rank(z)$ is in a different block than $rank(p(x))$.
After the find, $z=p(x)$, so the find operation causes
$rank(p(x))$ to move into a different (and larger) block
than it was in before the find.
Since successive blocks double in size, this can happen at
most $\lg \lg n$ times before $rank(p(x))$ exceeds $\lg n$,
so the number of find steps that can occur at node $x$ while
$x$ is a non-singular node on level 2 is at most $\lg \lg n$.
Hence, the total number of find steps that occur at 
non-singular nodes on level 2 is $O(n\log\log n)$.
<p>
This leaves the case of non-singular nodes on level 1.
Let's suppose that $x$ is such a node and that
$\textit{block}(j)$ is the subset of the integers that
includes $\textit{rank}(x)$.
A find involving $x$ will assign a new parent to $x$ causing
$rank(p(x))$ to increase by at least 1.
Since $\textit{block}(j)$ contains $2^j$ values, this can happen
no more than $2^j$ times while $x$ is on level 1.

To bound the total number of find steps at non-singular level 1 nodes, 
the number of nodes in $block(j)$ must be bounded.
This bound, can be obtained with the help of another lemma.
<p>
<i>Lemma 2</i>.
For any integer $k>0$,
the number of nodes of rank $k$ is at most $n/2^k$.
Consequently, the number of nodes with rank $\geq k$ is
less than $2n/2^k$.
<p>
<i>Proof</i>. Suppose that when a node $x$ is assigned a rank of $k$,
all nodes in the tree with root $x$ are labeled $(x,k)$.
By Lemma 1,
at least $2^k$ nodes are labeled when $x$ receives a rank of $k$.
If the root of the tree containing $x$ changes, the new root must have
rank at least $k+1$, so no node is labeled more than once with a
label of the form $(y,k)$ for a particular value of $k$.
Since there are $n$ nodes, there are at most $n$ labels of
the form $(y,k)$ for any particular $k$ and there are at least $2^k$
such labels for each node of rank $k$.
Hence, at most $n/2^k$ nodes can be assigned a rank of $k$. 
Summing $n/2^j$ for all values of $j\geq k$ yields $2n/2^k$,
so the number of nodes with rank $\geq k$ is at most $2n/2^k$.
$\square$
<p>
Now, since a node with rank in $block(j)$ has rank at least $2^j$,
the number of nodes in $block(j)$ is at most $2n/2^{2^j}$.
Consequently, the number of find steps that occur at non-singular
nodes on level 1 with rank in $block(j)$ is at most
$2^{j} \left( 2n/2^{2^j} \right)$.
There are no non-singular nodes with rank in $\textit{block}(0)$,
so summing this expression over all values of $j > 0$ yields
$$
2n\sum_{j>0} 2^j/{2^{2^j}} \leq 2n\sum_{j>0} j/{2^j} \leq 4n
$$
The first inequality above holds because every term in the summation
on the left-hand side is also present in the summation on the right-hand
side (along with many additional terms).
The second inequality follows directly from the formula for
an unbounded arithmetic-geometric series.
Hence, the number of find steps at non-singular nodes on level 1 is $O(n)$.
Combining this with the results from the other cases,
the total number of find steps is $O(m+n\log\log n)$.
Note that for $m\geq n\lg\lg n$, the number of find steps is $O(m)$,
so it's only possible to improve the analysis when $m< n\lg\lg n$.
<p>
Before proceeding further, let's recap.
In the analysis just completed, the find steps were divided
into three categories.
<ul>
<li> <i>Steps at singular nodes</i>. For each find operation, there are at
    most two of these, for a total of at most $2m$.
<li> <i>Steps at non-singular nodes on level 1</i>. The total number
    of these steps is $O(n)$.
<li> <i>Steps at non-singular nodes on level 2</i>. Each node
    experiences at most $\lg \lg n$ of these, for a total
    of at most $n \lg \lg n$.
</ul>
To improve on this result, a better bound on the number of find
steps in the last category is needed.

<h4>An Even Better (but not quite best) Analysis</h4>

The analysis from the last section can be improved by
dividing the case of non-singular nodes on level 2 into two sub-cases.
First let's define a second, coarser partition on
the integers, by letting

\begin{eqnarray*}
\textit{block}_2(0)&=&[0,4) \\
\textit{block}_2(1)&=&[4,16)=\left[2^2,2^{2^2}\right) \\
\textit{block}_2(2)&=&[16,65536]=\left[2^{2^2},2^{2^{2^2}}\right)
\end{eqnarray*}
and in general
$$
\textit{block}_2(j)=\left[2^{[j]},2^{[j+1]}\right)
$$
where $2^{[1]}=2^2$ and $2^{[j]}=2^{2^{[j-1]}}$ for $j>1$.
For notational consistency, let $\textit{block}_1(j)$ denote
the original partition of the integers.
<p>
Now, a node $x$ is defined to be <i>on level 1</i> if
there is an interval defined by $\textit{block}_1$ that contains
both $\textit{rank}(x)$ and $rank(p(x))$.
Node $x$ is defined to be <i>on level 2</i> if it is not on level 1
and there is an interval defined by $\textit{block}_2$ that
contains both $\textit{rank}(x)$ and $rank(p(x))$.
Nodes that are on neither level 1 nor level 2 are on level 3.
So, in the example below, nodes $a$ and $d$ are on level 1,
$b$ is on level 2 and $c$ is on level 3.
As before, a node is called singular if none of its ancestors
is on the same level that it is.
So, in the example, nodes $b$, $c$ and $d$ are singular.
<p>
<div  style="text-align:center;">
<img width="500" src="figs/dsetsAnalysis2a.png"><br>
</div>
<p>
As before, a case analysis is used,
but now there are four cases to consider.
<ul>
<li> <i>Steps at singular nodes</i>. Since there are just three
    levels, each find operation can have at most
    three find steps at singular nodes.
    This gives a total of at most $3m$ find steps in this category.
<li> <i>Steps at non-singular nodes on level 1</i>. The  previous analysis
    applies directly to this case, so as before, the number of
    find steps for non-singular nodes on level 1 is $O(n)$.
<li> <i>Steps at non-singular nodes on level 2</i>.
    It is shown below that the number of find steps in this group is $O(n)$.
<li> <i>Find steps at non-singular nodes on level 3</i>.
    It is shown below that the number of find steps in this group
    is $O(n\beta(n))$, where $\beta(n)$ is a very slowly growing function.
</ul>

Let's proceed with the analysis of the third case.
Let $x$ be a non-singular node with $\textit{rank}(x)$ in $\textit{block}_2(j)$. 
Because $x$ is on level 2, its parent's rank is in a different
level 1 interval than its rank. Because it is non-singular, it has a
proper ancestor $y$ that is also on level 2. 
Consequently, the root of the tree has rank that is in a
different level 1 interval than $rank(p(x))$.
This means that a find involving $x$ causes
$rank(p(x))$ to move to a different level 1 interval.
Hence, the number of find steps that occur at $x$ while it
is non-singular and on level 2 is less than the
number of level 1 intervals that intersect $block_2(j)$,
and this at most $2^{[j]}-2^{[j-1]}<2^{[j]}$,
as illustrated below.
<p>
<div  style="text-align:center;">
<img width="500" src="figs/dsetsAnalysis3.png"><br>
</div>
<p>
Since the number of nodes with rank in $block_2(j)$
is $\leq 2n/2^{2^{[j]}} = 2n/2^{[j+1]}$ for $j>0$,
the number of find steps at non-singular nodes
on level 2 is at most 
$2^{[j]} \left( 2n/2^{[j+1]} \right)$ for $j>0$.
There can be no non-singular nodes on level 2 with
rank in $\textit{block}_2(0)$,
so, the total number of find steps that occur at
non-singular nodes on level 2 is at most
$$
2n\sum_{j>0} 2^{[j]}/{2^{2^{[j]}}} \leq 2n\sum_{j>0} j/2^j \leq 4n
$$

That leaves just the fourth case.
Let $x$ be a non-singular node with $\textit{rank}(x)$ in $\textit{block}_2(j)$.
Because $x$ is on level 3, its parent's rank is in a different
level 2 interval than its rank. Because it is non-singular, it has a
proper ancestor $y$ that is also on level 3. 
Consequently, the root of the tree has a rank that is in a
different level 2 interval than $rank(p(x))$.
This means that a find involving $x$ causes
$rank(p(x))$ to move to a different level 2 interval.
Consequently, the number of find steps that can occur at $x$
while it is non-singular and on level 3 is bounded by the number
of level 2 intervals that include values $\leq \lg n$.
If $\beta(n)$ is defined to be the smallest integer $i>0$ for which 
$2^{[i]}> \lg n$, then the number of level 2 intervals that includes
values $\leq \lg n$ is $\beta (n)$ and the number of find steps at
any non-singular node on level 3 is at most $\beta(n)$.
The function $\beta(n)$ grows extremely slowly with $n$;
in general $\beta(2^{[k]})=k$.
<p>
Putting together the results from the four cases above,
the total number of find steps is $O(m + n\beta(n))$.
Observe now that with this analysis, the number of find steps is $O(m)$
whenever $m \geq n\beta(n)$, so the analysis can be improved only
for $m < n\beta(n)$.
This can be done by further sub-dividing the fourth case.

<h4>The Final Analysis</h4>
The key to this final analysis is to
allow the number of distinct cases to grow further.
This can be done by defining a series of partitions on the
integers, $block_1$, $block_2$, $block_3$
and so forth, with each partition
coarser than the previous one, and with the last partition requiring just
a single interval to span the range up to $\lg n$.
Specifically, for $i>0$, $\textit{block}_i(0)$ starts at 0 and for all
$j>0$, $\textit{block}_i(j)$ starts
with $A_i(j)$, where $A$ is <i>Ackerman's function</i> and is defined as
follows.
$$
A_i(j) = \left\{
\begin{array}{ll}
2^j & \textrm{for $i=1$, $j\geq 1$} \\
A_{i-1}(2) & \textrm{for $i>1$, $j=1$} \\
A_{i-1}(A_i(j-1)) & \textrm{for $i,j>1$}
\end{array} \right.
$$
It can be helpful to think of Ackerman's function as a family
of related functions $A_i$. The notation used here was chosen
to emphasize that viewpoint.
Notice that with this definition, $A_2(j)=2^{[j]}$ for all $j\geq 1$.
Consequently this definition of the blocks is consistent with the
earlier definitions of $\textit{block}_1$ and $\textit{block}_2$.
Now, define a functional inverse $\alpha$ of Ackerman's function.
$$
\alpha(m,n)=\min \{i\geq 1 | A_i(\lceil m/n \rceil)>\lg n\}
$$
This means that, $A_{\alpha(m,n)}$ defines at most $\lceil m/n \rceil$
intervals that contain values $\leq \lg n$.
The definition of $\textit{block}_{\alpha(m,n)}$ is
simplified to include just a single interval $[0,\ldots,\lfloor \lg n \rfloor]$.
<p>
As before, the non-root nodes are assigned to levels.
Specifically, a node $x$ is defined to be on level 1
if $\textit{rank}(x)$ and $rank(p(x))$ are both in some interval
defined by $block_1)$.
For $1 < i\leq \alpha(m,n)+1$, $x$ is defined to be on level $i$ if it is not
on level $i-1$ and there is some interval defined by $block_i$ that contains
both $\textit{rank}(x)$ and $rank(p(x))$.
Node $x$ is called <i>singular</i> if it has no proper ancestor
on the same level as $x$.
<p>
As before, the analysis can be broken down into cases.
<ul>
<li> <i>Steps at singular nodes</i>. Since there are $\alpha(m,n)+1$ levels,
    the number of find steps at singular nodes is at most
    $m(\alpha(m,n)+1) = O(m\alpha(m,n))$.
<li> <i>Steps at non-singular nodes on level 1</i>. The previous analysis
    applies directly to this case, so the number of
    find steps in this case is $O(n)$.
<li> <i>Steps at non-singular nodes on level $i$ for
    $1< i\leq \alpha(m,n)$</i>.
    It is shown below that the number of find steps covered by
    this case is $O(n\alpha(m,n))$.
<li> <i>Steps at non-singular nodes on level $\alpha(m,n)+1$</i>. 
    By the argument used previously,
    a node can experience at most $\lceil m/n \rceil$ find
    steps while it is non-singular and on level $\alpha(m,n)+1$.
    Hence the total number of find steps covered by this case is
    $\leq \lceil m/n \rceil n \leq m+n$.
</ul>
Proceeding with the analysis of the third case,
let $x$ be a non-singular node on level $i$ ($1 < i\leq \alpha(m,n)$)
and assume that $\textit{block}_i(j)$ includes $\textit{rank}(x)$.
Because $x$ is on level $i$, its parent's rank is in a different
interval on level $i-1$ than its rank. Because it is non-singular, it has a
proper ancestor $y$ that is also on level $i$. 
Consequently, the root of the tree has rank that is in a
different interval on level $i-1$ than $rank(p(x))$.
Hence, a find involving $x$ causes
$rank(p(x))$ to move to a different interval on level $i-1$.
This means that the number of find steps that $x$ can experience
while it is non-singular and on level $i$ is bounded by the number
of intervals on level $i-1$ that intersect $\textit{block}_i(j)$.
Call this number $b_i(j)$ and note that $b_i(0)=2$ for all
$i$ and that for $j>0$, $b_i(j) \leq A_i(j)-A_i(j-1)< A_i(j)$,
as illustrated below.
<p>
<div  style="text-align:center;">
<img width="600" src="figs/dsetsAnalysis4.png"><br>
</div>
<p>
Since the number of nodes with rank in $block_i(j)$
is $\leq 2n/2^{A_i(j)}$, the number of find steps
experienced by non-singular nodes on level $i$ whose
rank is in $\textit{block}_i(j)$ is at most 
$A_i(j) \left( 2n/2^{A_i(j)}\right)$ for $j>0$.
There are no non-singular nodes with rank in $\textit{block}_i(0)$ for all $i$,
so the total number of find steps experienced by non-singular nodes
on levels 2 through $\alpha(m,n)$ is at most
\begin{eqnarray*}
2n \sum_{2\leq i \leq \alpha(m,n)} \sum_{j>0} A_i(j)/2^{A_i(j)}
&\leq& 2n \sum_{2\leq i \leq \alpha(m,n)} \sum_{j>0} j/2^j \\
&\leq& 2(\alpha(m,n)-1)n \sum_{j>0} j/2^j \\
&\leq& 4(\alpha(m,n)-1) n
\end{eqnarray*}
Combining the bounds in the four cases gives $O((m+n)\alpha(m,n))$
for a sequence of $m$ find operations.
<p>
To compare this result with the previous one,
one must compare the growth rates of $\alpha$ and $\beta$.
Note that $\alpha$ grows most quickly when $m\leq n$.
In this case,
$\alpha(m,n)=\alpha(n,n)=\min \{i\geq 1 | A_i(1)>\lg n\}$.
For the smallest values of $n$, $\alpha(n,n)$ and $\beta(n)$
remain fairly close, but while $\beta(2^{[5]})=5$,
$\alpha(n)$ does not become 5 until $n$ reaches $2^{[65537]}$.
By that point, $\beta(n)=65537$ and from there,
$\beta$ continues to grow much faster than $\alpha$.
Finally, it's worth noting that for $m\geq n \beta(n)$, $\alpha(m,n) \leq 2$.
So, this is analysis is consistent with the previous analysis when
$m\geq n \beta(n)$.

<a id=scanner><h2>Scanner</h2></a>
The <code>Scanner</code> class is a utility class used by the various
data structures to implement their <code>fromString</code>  methods.
It is initialized with a string and
provides a variety of helper methods for incrementally parsing that string.
It maintains a <i>cursor</i> that defines the current position
in the string; the cursor is updated as portions of the string are parsed.
<ul>
<li>    <code>constructor(s)</code> initializes the object making $s$ the
        string to be scanned and setting the cursor to 0.
<li>    <code>reset(i=0, s=this.s)</code> resets the object; the
        cursor is reset to <code>i</code> (default value 0)
        and the string is optionally reset to the argument <code>s</code>
        (if <code>s</code> is omitted, the string remains unchanged).
        If <code>i</code> is negative, it is added to the cursor,
        effectively moving it back the specified number of positions.
<li>    <code>cursor</code> returns the position of the cursor in the string.
<li>    <code>length</code> is the number of unscanned characters remaining.
<li>    <code>toString()</code> returns the unparsed portion of the string.
<li>    <code>firstNonSpace(i0=0)</code> returns the position of the
        first non-space character starting at the cursor plus <code>i0</code>
        characters.
<li>    <code>skipSpace()</code> advances the cursor to the next non-space
        character.
<li>    <code>isdigit(c)</code> returns true if <code>c</code> is a
        numerical digit.
<li>    <code>islower(c)</code> returns true if <code>c</code> is a
        lower-case letter.
<li>    <code>isupper(c)</code> returns true if <code>c</code> is a
        upper-case letter.
<li>    <code>verify(s, skip=true)</code> returns true if <code>s</code>
        is a prefix of the unscanned portion of the string. If 
        <code>skip==true</code>, the cursor is first advanced to the
        next non-space character. When <code>verify</code> returns true,
        it also advances the cursor past the verified string.
<li>    <code>nextInt()</code> scans the string for an integer
        (possibly signed), skipping
        past leading space characters. If it finds an integer value,
        it returns that value and advances the cursor. Otherwise, it
        returns NaN and leaves the cursor unchanged.
<li>    <code>nextNumber()</code> scans the string for a number (may be
        integer or floating point), skipping
        past leading space characters. If it finds a number,
        it returns its value and advances the cursor. Otherwise, it
        returns NaN and leaves the cursor unchanged.
<li>    <code>nextWord()</code> scans the string for a word
        (an alphanumeric string, possibly including underscores, that
        starts with a non-digit), skipping
        past leading space characters. If it finds a word,
        it returns it and advances the cursor. Otherwise, it
        returns an empty string and leaves the cursor unchanged.
<li>    <code>nextLine()</code> scans the string for a newline character
        and returns the string up to and including the newline.
        If there is no complete line remaining in the string,
        it returns an empty string and leaves the cursor unchanged.
<li>    <code>nextIndex(prop=0)</code> scans the string for a either a single
        lower-case letter or an integer, skipping
        past leading space characters. If it finds a letter, it returns
        the letter's position in the alphabet
        (1 for $a$, 2 for $b$ and so forth) and advances the cursor.
        If it finds an integer, it returns the integer and advances the cursor.
        Otherwise, it returns 0 and leaves the cursor unchanged.
		The optional argument <code>prop(i)</code> is called with index
		<code>i</code>just before <code>nextIndex</code> returns <code>i</code>.
		It can be used to enable parsing of input tokens that include
		additional information. For example, in a list data structure,
		the string <code>'c:5'</code> might represent an item <code>c</code>
		with some associated numerical property.
<li>    <code>nextIndexList(ld, rd, prop=0)</code> scans the string for a
        list of index values (either lower-case letters or integers)
        separated by spaces and delimited by the delimiter characters
        <code>ld</code> and <code>rd</code>.
        So for example, if the next portion of the
        string in <code>scanner</code> is
        <code>"[ a b 5 )"</code>, then
        <code>scanner.nextIndexList('[', ')')</code>
        returns the array <code>[1, 2, 5]</code>.
		The individual index values in the list are parsed using
		<code>nextIndex</code> and the optional argument <code>prop(i)</code>
		is passed to <code>nextIndex</code>. This allows one to use
		<code>nextIndexList</code> to parse strings like 
		<code>"[1:3 e:2 c:1]"</code>, for example.
        If a valid list is found, it is returned as an array and the
        cursor is advanced.
        Otherwise, <code>null</code> is returned and
        the cursor is left unchanged.
</ul>

<h2>References</h2>
<dl>
<dt> [Tarjan87]
<dd> Tarjan, R. E., <i>Network Algorithms and Data Structures</i>.
     Society for Industrial and Applied Mathematics, 1987.
</dl>
<hr> <h4>&copy; Jonathan Turner - 2022</h4>
<script src="../googleAnalytics.js"></script>
</body>
</html>
