<html>
<head>
<title>Heaps</title>
<link type="text/css" rel="stylesheet" href="../main.css">
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</head>
<body bgcolor=ffffff>

<h2>Heaps</h2>

A heap $h$ is an abstract data type that represents
a collection of items, where each item has a numeric <i>key</i>.
A typical heap implementation supports the following methods.
<ul>
<li> $\textit{insert}(i, k)$ inserts item $i$ into the heap with key $k$.
<li> $\textit{deletemin}()$ deletes a minimum key item from the heap and
    returns it.
<li> $\textit{changekey}(i, k)$ changes the key of heap item $i$ to $k$.
</ul>
It is also common to include a <i>findmin</i> method, which returns the item
with the smallest key without deleting it, and a general <i>delete</i> method.
<p>
Efficient heap implementations are usually built around the idea of a
<i>heap-ordered tree</i>,
which is a tree in which each heap item $i$ is viewed as a tree node and
$\textit{key}(i) \geq \textit{key}(p(i))$ where 
$p(i)$ is the parent of $i$ in the tree.
This property ensures that the root of the tree has the
smallest key value.
Using a suitably structured heap-ordered tree, the various operations
can be implemented to run in $O(\log n)$ time.

<a id=arrayHeap><h2>Array Heap</h2></a>
The <i>array heap</i> (also known as $d$-heap) is a simple version
of the heap data type that uses an array to implement a
$d$-ary heap-ordered tree.
The provided <i>Javascript</i> implementation
includes the following methods in addition to the
three standard ones mentioned earlier.
<ul>
<li>    <code>d</code> returns the &ldquo;arity&rdquo; of the heap-ordered tree.
<li>    <code>m</code> returns the number of items in the heap
        (note, this is not the same as the index range).
<li>    <code>key(i)</code> returns the key of item <code>i</code>.
<li>    <code>empty()</code> returns true if the heap is empty.
<li>    <code>contains(i)</code> returns true if item <code>i</code>
        is in the heap.
<li>    <code>findmin()</code> returns the item with the smallest key.
<li>    <code>delete(i)</code> deletes item <code>i</code> from the heap.
<li>    <code>add2keys(delta)</code> adds the value <code>delta</code>
        to the keys of all heap items.
</ul>
<p>
The web app  can be used to construct a heap from a string and
try out its methods as shown below.
<pre style="padding-left:5%;">
let h = new ArrayHeap(10);
h.fromString('{e:1 f:2 c:5 a:5 d:2 h:7 i:7 j:8 b:6 g:4}');
log(h.toString(1));
let u = h.deletemin();
log(h.index2string(u), h.key(u), ''+h);
</pre>
This produces the output
<pre style="padding-left:5%;">
{e:1(f:2(a:5(j:8 b:6) d:2(g:4)) c:5(h:7 i:7))} 
e 1 {f:2 d:2 a:5 j:8 b:6 g:4 c:5 h:7 i:7} 
</pre>
The first line shows a detailed view of the heap,
before the <code>deletemin</code> operation.
Parentheses are used to indicate the tree structure.
Specifically, each item with children in the tree is
immediately followed by a parenthesized list of its children.
The final line includes a more concise view of the heap,
just listing all the remaining items and their keys, in some unspecified order.
<p>
The implementation of the array heap stores the $m$ heap items
in positions $1\ldots m$ of an array with the positions of items
determining the relationship between parents and children
in an implicit heap-ordered tree.
This tree has a characteristic <i>heap-shape</i>,
which is illustrated in the example below.
<p>
<div  style="text-align:center;">
<img width="400" src="figs/dheap1.png"><br>
</div>
<p>
The index of an item in the <i>item</i> array is referred to as
its <i>position</i> in the heap,
so in the example, item $b$ is at position 3. The index of a value in the
<i>key</i> array is an item number. Here, they are shown as letters to make it
easier to distinguish the items from the other numeric values.
For a heap item $i$ stored at position $x>1$,
the parent of $i$ is stored at position $\lceil (x-1)/d \rceil$.
Consequently, the children of $i$ (if any) are stored starting at
position $d(x-1)+2$ and continuing consecutively from there.
If $i$ has $d$ children its &ldquo;rightmost&rdquo; is stored at
position $dx+1$.
A third array $pos$ is included to support a general <i>delete</i> method; 
$pos[i]$ gives the position of item $i$ in the <i>item</i> array.
<p>
To insert a new item $u$ into a heap with key $k$, start at the
first unused position in the item array, then go up the tree looking
for the first item with a key that is $\leq k$. The new item
becomes a child of that item and the other items along the path
all move down one level in the tree. So for example, inserting item $l$
with key 5 into the previous example heap yields the following.
<p>
<div  style="text-align:center;">
<img width="350" src="figs/dheap2.png"><br>
</div>
<p>
The insertion is done with the assistance of a helper method
$\textit{siftup}(i, x)$, which scans for a position for item $i$ starting
from position $x$, moving items down as it goes, before inserting $i$
into its final position.
<p>
$\textit{Deletemin}$ is implemented in a similar way.
Let $i$ be the last item in the <i>item</i> array and let
Let $k = \textit{key}(i)$.
Starting from the root, scan down the heap looking for a
new place to insert $i$. 
At each step, select the
child of the current item that has the smallest key.
When this process reaches an item with a key that is at least as large as $k$,
item $i$ is inserted just above that item, while the other items in
the search path are moved up one level.
So for example, a $\textit{deletemin}$ on the heap
from the last example, yields the configuration shown below.
<p>
<div  style="text-align:center;">
<img width="350" src="figs/dheap3.png"><br>
</div>
<p>
The search process described above is implemented by
a helper method called <i>siftdown</i>.
The core methods for the <code>Dheap</code> class are shown below.
<p>
<textarea id="components" rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class ArrayHeap extends Top {
    #d;            ///< base of heap
    #m;            ///< # of items in the heap set

    #item;         ///< {#item[1],...,#item[m]} is the items in the heap
    #pos;          ///< #pos[i] gives position of i in #item
    #key;          ///< #key[i] is key of item i
    #offset;       ///< offset for key values, allowing all to shift at once

    #insertCount;        // calls to insert
    #deleteCount;        // calls to delete
    #changekeyCount;    // calls to changekey
    #siftupSteps;        // steps taken by siftup
    #siftdownSteps;        // steps taken by siftdown

    /** Constructor for ArrayHeap object.
     *  @param n is index range for object
     *  @parm d is the base of the heap (defaults to 4)
     *  @param capacity is maximum index range (defaults to n)
     */
    constructor(n, d=4, capacity=n) { super(n); this.#init(d, capacity); }
    
    /** Allocate space and initialize ArrayHeap object.
     *  @param d is the base of the heap.
     *  @param capacity is the maximum range
     */
    #init(d, capacity) {
        this.#item = new Int32Array(capacity+1);
        this.#pos = new Int32Array(capacity+1);
        this.#key = new Float32Array(capacity+1);
        this.#item[0] = this.#m = 0; this.#d = d;
        this.#offset = 0;
        this.clearStats();
    }

    /** Remove all elements from heap. */
    clear() {
        for (let x = 1; x <= this.#m; x++) this.#pos[this.#item[x]] = 0;
        this.#m = 0; this.#offset = 0;
        this.clearStats();
    }

    get capacity() { return this.#item.length-1; }

    get d() { return this.#d; }

    get m() { return this.#m; }

    /** Return position of parent of a heap item.
     *  @param p is position of item in heap
     *  @param return position where parent would go if there were one
     */
    p(pos) { return Math.ceil((pos-1)/this.d); }

    /** Return position of leftmost child of a heap item.
     *  @param pos is position of item in heap
     *  @param return position where left child would go if there were one
     */
    left(pos) { return this.d*(pos-1)+2; }

    /** Return position of rightmost child of a heap item.
     *  @param pos is position of item in heap
     *  @param return position where right child would go if there were one
     */
    right(pos) { return this.d*pos+1; }
    
    /** Find an item in the heap with the smallest key.
     *  @return the number of an item that has the smallest key
     */
    findmin() { return this.empty() ? 0 : this.#item[1]; }
    
    /** Delete a minimum key item from the heap and return it.
     *  @return an item of minimum key from the heap, after deleting it
     *  from the heap
     */
    deletemin() {
        if (this.empty()) return 0;
        let i = this.#item[1]; this.delete(i);
        return i;
    }
    
    /** Get the key of an item.
     *  @param i is an item in the heap
     *  @return the value of i's key
     */
    key(i) { return this.#offset + this.#key[i]; }

    add2keys(delta) { this.#offset += delta; }
    
    /** Determine if an item is in the heap.
     *  @param i is an item
     *  @return true if i is in the heap, else false
     */
    contains(i) { return this.#pos[i] != 0; }
    
    /** Determine if the heap is empty.
     *  @return true if heap is empty, else false
     */
    empty() { return this.m == 0; };
    
    /** Add index to the heap.
     *  @param i is an index that is not in the heap
     *  @param key is the key value under which i is to be inserted
     */
    insert(i, key) {
        assert(i > 0);
        this.#insertCount++;
        if (i > this.capacity) this.expand(i);
        this.#key[i] = key - this.#offset; this.#m++; this.#siftup(i, this.m);
    }
    
    /** Remove an index from the heap.
     *  @param i is an index in the heap
     */
    delete(i) {
        assert(i > 0);
        this.#deleteCount++;
        let j = this.#item[this.#m--];
        if (i != j) {
            if (this.#key[j] <= this.#key[i])
                this.#siftup(j, this.#pos[i]);
            else
                this.#siftdown(j, this.#pos[i]);
        }
        this.#pos[i] = 0;
    }
    
    /** Perform siftup operation to restore heap order.
     *  This is a private helper function.
     *  @param i is an item to be positioned in the heap
     *  @param x is a tentative position for i in the heap
     */
    #siftup(i, x) {
        this.#siftupSteps++;
        let px = this.p(x);
        while (x > 1 && this.#key[i] < this.#key[this.#item[px]]) {
            this.#item[x] = this.#item[px]; this.#pos[this.#item[x]] = x;
            x = px; px = this.p(x);
            this.#siftupSteps++;
        }
        this.#item[x] = i; this.#pos[i] = x;
    }
    
    /** Perform siftdown operation to restore heap order.
     *  This is a private helper function.
     *  @param i is an item to be positioned in the heap
      *  @param x is a tentative position for i in the heap
      */
    #siftdown(i, x) {
        let cx = this.#minchild(x);
        while (cx != 0 && this.#key[this.#item[cx]] < this.#key[i]) {
            this.#item[x] = this.#item[cx]; this.#pos[this.#item[x]] = x;
            x = cx; cx = this.#minchild(x);
        }
        this.#item[x] = i; this.#pos[i] = x;
    }
    
    /** Find the position of the child with the smallest key.
     *  This is a private helper function, used by siftdown.
     *  @param x is a position of an index in the heap
     *  @return the position of the child of the item at x, that has
     *  the smallest key
     */
    #minchild(x) {
        this.#siftdownSteps++;
        let minc = this.left(x);
        if (minc > this.m) return 0;
        for (let y = minc + 1; y <= this.right(x) && y <= this.m; y++) {
            this.#siftdownSteps++;
            if (this.#key[this.#item[y]] < this.#key[this.#item[minc]])
                minc = y;
        }
        return minc;
    }
    
    /** Change the key of an item in the heap.
     *  @param i is an item in the heap
     *  @param k is a new key value for item i
     */
    changekey(i, k) {
        this.#changekeyCount++;
        let ki = this.#key[i] - this.#offset;
        this.#key[i] = k - this.#offset;
        if (k == ki) return;
        if (k < ki) this.#siftup(i, this.#pos[i]);
        else this.#siftdown(i, this.#pos[i]);
    }
}
</textarea>
<p>
The running time for <i>siftup</i> is $O(\log_d n)$, while
the running time for <i>siftdown</i> is $O(d \log_d n)$.
The <i>changekey</i> operation can also be implemented using
<i>siftup</i> to reduce the key value and <i>siftdown</i> to increase
the key value. Hence, its running time is either $O(\log_d n)$
or $O(d \log_d n)$, depending on whether the key is increased or
decreased.
In some applications key reductions may occur more frequently than
other operations. In such cases, the overall performance can be
improved by selecting a value of $d$ that makes these operations faster
at the expense of the others.
The <code>add2keys</code> method is implemented by adding a value
to a hidden offset that is used to interpret the key values.
This allows the operation to be done in constant time.

<a id=fheaps><h2>Fibonacci Heaps</h2></a>

The Fibonacci heaps [FredTarj87] data structure represents a collection
of heaps that define a partition over a common index range $1\ldots n$.
Each heap is identified by one of its items.
The data structure supports an efficient <i>meld</i> operation which
combines two heaps into a single heap.
It also can implement a <i>changekey</i> operation that takes
essentially constant time when the key value is reduced;
operations that increase the key value take $O(\log n)$ time.
More precisely, in a sequence of $m$ heap operations including
$d$ <i>delete</i>, <i>deletemin</i> and increasing <i>changekey</i>
operations, the total running time is $O(m + d\log n)$.
<p>
The <i>Javascript</i> implementation includes the following methods.
<ul>
<li>    <code>key(i)</code> returns the key of item <code>i</code>.
<li>    <code>setKey(i, k)</code> sets the key of item <code>i</code>
        to <code>k</code>; item <code>i</code> must define a singleton
        heap.
<li>    <code>singleton(i)</code> returns true if <code>i</code> is the
        only item in its heap.
<li>    <code>findmin(h)</code> returns the item of minimum key in the
        heap identified by item <code>h</code>.
<li>    <code>deletemin(h)</code> returns the item of minimum key in the
        heap identified by <code>h</code> and removes it from
        <code>h</code>.
<li>    <code>delete(i, h)</code> deletes <code>i</code> from the
        heap identified by <code>h</code>.
<li>    <code>meld(h1, h2)</code> combines the two heaps identified by
        <code>h1</code> and <code>h2</code> and returns the identifier of
        the combined heap.
<li>    <code>insert(i, h, k)</code> inserts <code>i</code> into the
        heap identified by <code>h</code> with key <code>k</code>.
<li>    <code>changekey(i, h, k)</code> changes the key of item
        <code>i</code> in the heap identified by <code>h</code>
        to <code>k</code>.
</ul>
Each heap in the data structure is represented by a collection
of heap-ordered trees. Each heap item $i$ has
a parent pointer $p(i)$ and a child pointer $c(i)$.
Siblings are linked by lists within a <code>ListSet</code> data structure.
That is, each set of siblings (in all the trees, in all the heaps)
defines a list within a single <code>ListSet</code> object.
The roots of the trees within each heap are also linked by
lists in the same object.
This structure is illustrated in the figure below that shows
a single heap consisting of three trees.
<p>
<div  style="text-align:center;">
<img width="600" src="figs/fheaps1.png"><br>
</div>
<p>
Each item in the heap has a <i>key</i> and two auxiliary properties,
a <i>rank</i> and a <i>mark</i>. For each item $i$,
$\textit{rank}(i)$ equals the number of children of $i$.
<p>
The first item in the root list of a heap is used as the heap identifier.
This is also the item with the smallest key.
Two heaps can be melded simply by combining their root lists.
An insert is essentially just a meld of a singleton heap with another heap.
<p>
The <code>deletemin</code> operation for a heap identified by <code>h</code>
is implemented by first removing <code>h</code> from the root list,
then combining its child list  with the root list.
Next, the root list is scanned to find the root with the smallest key.
The heap is restructured at the same time to speed up later operations.
In particular, trees with roots of equal rank are combined, with one tree
becoming a subtree of the other's root.
This is illustrated below.
<p>
<div  style="text-align:center;">
<img width="500" src="figs/fheaps2.png"><br>
</div>
<p>
This procedure can be implemented
by inserting each tree root into an array at the position determined by
its rank.
Whenever such an insertion would <i>collide</i> with a previously inserted
root, the two trees are combined with one becoming the subtree of
the other tree's root (based on key value).
The root that was previously in the array is removed and
the root of the new tree is inserted at the position determined
by its new rank. If this leads to a new collision, the process is repeated.
<p>
This restructuring process reduces the number of trees, speeding up
subsequent <code>deletemin</code> operations.
It also leads to a useful property, that can be
observed in the example above. Note that after the process completes,
the root node has a rank of 3, while its children have ranks of 2, 1 and 0,
respectively. 
Also observe, that every node in the tree with a rank of $k$ has $2^k$
nodes in its subtree. 
This leads to an upper bound of $\lg n$ on the rank of any node.
<p>
Before discussing the <code>changekey</code> operation, let's analyze
the performance of a sequence of <code>insert</code> and
<code>deletemin</code> operations only.
Let's start by showing that the property observed in the example
is in fact a general property.
<p>
<i>Lemma 1</i>. Let $x$ be any node with rank $r$ and children $y_1,\ldots,y_r$,
where the children are listed in the order that they became children of $x$.
Then, $\textit{rank}(y_i) \geq i-1$.
<p>
<i>Proof</i>.
First note, that if the only operations are <code>insert</code> and 
<code>deletemin</code>, then only tree roots are ever removed from a heap.
That means that no node in the heap ever loses a child.
Also, a node can only become the child of another during the
restructuring process performed by the <code>deletemin</code> operation.
Consequently, just before $y_i$ became a child of $x$, $x$ had
$i-1$ children. Since $y_i$ became a child of $x$ it must have collided
with $x$ during the restructuring process and hence it must have had
$i-1$ children, and since it hasn't lost any children
it must still have $i-1$. $\Box$
<p>
<i>Corallary 1</i>. A node $x$ with rank $r$ has $2^r$ descendants in
its subtree.
<p>
<i>Proof</i>. The proof is by induction on the rank, and clearly holds for
$r=0$. For $r > 0$, the induction hypothesis and lemma imply that $x$ has
$1 + 2^0+2^1+\cdots+2^{r-1} = 2^r$ descendants. $\Box$
<p>
This implies that the maximum rank is $\leq \lg n$,
and that can be used to show that the initialization of the
data structure followed by any sequence $m$ operations
including $d$ <code>deletemin</code> operations
takes $O(n + m + d\log n)$ time.
This is done using a form of <i>amortized analysis</i> in which a set
fictitious <i>credits</i> are allocated for each operation and
used to &ldquo;pay&rdquo; for computational steps.
Credits that are not needed to pay for a particular operation can be saved
and used to pay for later operations. To ensure that there are always
enough credits available, the algorithm adopts the following
<i>credit policy</i>
<p style="padding-left:5%;">
Maintain one credit on-hand for every tree in all the heaps.
<p>
Note that the initialization of the data structure takes $O(n)$ time
and leaves us with exactly $n$ trees. So, if $2n$ credits are allocated
for the initialization, $n$ can be used to pay for the computation,
leaving us with $n$ credits that can be used to satisfy the credit
policy.
Since an <code>insert</code> operation takes constant time and does not
change the number of trees, a single credit can be allocated for each
<code>insert</code> and used to pay for the operation.
<p>
For the <code>deletemin</code> operation the inital step of 
removing the minimum key item from the root list and merging
its children into the root list takes constant time,
so can be payed for with a single credit.
The remaining time is determined by the number of steps in
the restructuring process. If the deleted item has rank $r$,
then the first step increases the number of trees by $r$, while the
restructuring process may decrease the number of trees.
If $p$ is the number of restructuring steps that involve a collision
and $q$ is number that do not, then the total number of steps is $p+q$
and the number of trees at the completion of the process is $r-p$
larger than at the start. So, to pay for the operation and ensure
that the credit policy is satisfied, $1+(p+q)+(r-p)=1+q+r$ credits must
be allocated to the <code>deletemin</code> operation.
Since both $q$ and $r$ are bounded by the maximum rank,
$1+ 2\lg n $ credits are sufficient.
<p>
This implies that the total number of credits allocated
for the initialization plus
$m$ operations including
$d$ <code>deletemin</code> operations is
$O(n+m+d\log n)$.
Since every computational step was paid for from allocated credits,
the running time is also $O(n+m+d\log n)$.
<p>
Now, it's time to consider the <code>changekey(i,h,k)</code>
operation.  When decreasing the key value, it can be
implemented by first changing the key value, removing the edge
from $i$ to its parent, then moving the resulting tree into the
root list.
This is a perfectly fine way of implementing <code>changekey</code>
but has the unfortunate side effect of breaking the analysis just
completed. In particular, the key lemma requires that no item ever
loses a child.
<p>
Fortunately, an alternate version of the lemma can be applied if
the operation is modified to ensure that no non-root
item loses more than one child.
The new version sets the mark bit of
a node $x$ whenever $x$ loses one of its children. If $x$ was
already marked, the edge from $x$ to its parent is also removed
(assuming $x$ is not a tree root) and the detached subtree is
added to the root list. If the parent was already marked, its subtree
is also removed and added to the root list.
This procedure is repeated until the parent of the subree to be
removed is unmarked.
The mark bits of all the new tree roots are cleared.
This process is illustrated below.
<p>
<div  style="text-align:center;">
<img width="400" src="figs/fheaps3.png"><br>
</div>
<p>
Here is the new version of the lemma.
<p>
<i>Lemma 2</i>. Let $x$ be any item with rank $r$ and children $y_1,\ldots,y_r$,
where the children are listed in the order that they became children of $x$.
Then, $\textit{rank}(y_i) \geq i-2$.
<p>
<i>Proof</i>.
As before, note that a item becomes the child of another during the
restructuring process performed by the <code>deletemin</code> operation.
Consequently, just before $y_i$ became a child of $x$, $x$ had
at least $i-1$ children. Since $y_i$ became a child of $x$ it must have collided
with $x$ during the restructuring process and hence it must have had
at least $i-1$ children, and since it has lost no more than one child
since it became a child of $x$, it must still have at least $i-2$. $\Box$
<p>
<i>Corallary 2</i>. A item $x$ with rank $r$ has at least $F_r$ descendants in
its subtree, where $F_r$ is the $r$-th Fibonacci number.
<p>
<i>Proof</i>. 
The proof is by induction on the rank, and clearly holds for
$r=0$ and $r=1$. For $r > 1$, the induction hypothesis and
lemma imply that $x$ has
at least $1 + F_0 + F_1 + \cdots + F_{r-2}$ descendants.
This sum is equal to $F_r$. $\Box$
<p>
The Fibonacci numbers satisfy the inequality $F_r \geq \phi ^{r-2}$
where $\phi = (1 + \sqrt{5})/2$. Consequently, the maximum rank
is $\leq 2 + \log_\phi n$.
<p>
To complete the analysis, the amortized complexity argument must be
extended to handle the decreasing <code>changekey</code> operation.
Here is a modified version of the credit policy.
<p style="padding-left:5%;">
Maintain one credit on-hand for every tree in all the heaps
plus two credits for every marked non-root item.
<p>
As before, if $2n$ credits are allocated
for the initialization, $n$ can be used to pay for the computation,
and the remainder is enough to satisfy the credit policy.
<p>
Since an <code>insert</code> or <code>meld</code> operation takes
constant time and does not change the number of trees or the number of
marked item, a single credit can be allocated for each
<code>insert</code> or <code>meld</code> and used to pay for the operation.
<p>
Since the <code>deletemin</code> operation makes no change to the number
of marked items, the previous argument can be applied directly.
The only change required is that the number of credits allocated to the step
must increased to $1 +  2(2+\log_\phi n)$.
<p>
To determine the number of credits needed for
a decreasing <code>changekey</code> operation,
let $k$ be the number of new subtrees created by the
operation. Observe that the number of marked non-root items decreases
by $k-1$, while the number of trees increases by $k$.
Consequently, $k-2$ fewer credits are needed to satify the credit policy
following the operation.
These $k-2$ credits plus 2 more are sufficient to pay for
the computational steps.
<p>
All that remains is to analyze the <code>delete</code> and the
increasing <code>changekey</code>. These can both be implemented in terms
of the other operations. Specifically,
the <code>delete</code> operation can be implemented by doing
a decreasing <code>changekey</code> followed by a <code>deletemin</code>.
The increasing <code>changekey</code> can be implemented as a
<code>delete</code> followed by an <code>insert</code>.
Consequently
the total number of credits allocated for the initialization plus
$m$ heap operations that include 
$d$ <code>delete</code>, <code>deletemin</code> and increasing
<code>changekey</code> operations is $O(n+ m + d\log n)$.
Since every computational step is paid for with allocated credits,
the running time is also $O(n+m+d\log n)$.
If $m\geq n$ (as it usually is), the bound can expressed more
simply as $O(m+d\log n)$.
<p>
The core methods of the <code>FibHeaps</code> class are shown below.
<p>
<textarea id="components" rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class FibHeaps extends Top {
    #key;         ///< #key[i] is key of item i
    #rank;        ///< #rank[i] gives rank of item i
    #mark;        ///< #mark[i] is true if item i is considered marked
    #p;           ///< #p[i] is the parent of item i in its heap
    #c;           ///< #c[i] is some child of item i in its heap
    #sibs;        ///< #sibs is a ListSet object containing sibling lists

    #rankVec;     ///< #rankVec is an auxiliary array used during restructuring
    #tmpq;        ///< #tmpq is a List object used as a temporary queue 

    #insertCount;
    #deleteCount;
    #changekeyCount;
    #decreasekeySteps;
    #mergeSteps;

    #MAXRANK = 32;

    /** Constructor for FibHeaps object.
     *  @param n is index range for object
     *  @parm d is the base of the heap (defaults to 2)
     *  @param capacity is maximum index range (defaults to n)
     */
    constructor(n, capacity=n) { super(n); this.#init(capacity); }
    
    /** Allocate space and initialize FibHeaps object.
     *  @param nMax is the maximum range
     */
    #init(capacity) {
        this.#key = new Float32Array(capacity+1);
        this.#rank = new Int32Array(capacity+1);
        this.#mark = new Int8Array(capacity+1);
        this.#p = new Int32Array(capacity+1);
        this.#c = new Int32Array(capacity+1);
        this.#sibs = new ListSet(this.n, capacity);

        this.#rankVec = new Int32Array(this.#MAXRANK+1);
        this.#tmpq = new List(this.n, capacity);

        this.#insertCount = 0;
        this.#deleteCount = 0;
        this.#changekeyCount = 0;
        this.#decreasekeySteps = 0;
        this.#mergeSteps = 0;
    }

    get capacity() { return this.#key.length-1; }

    /** Remove all elements from heap. */
    clear() {
        this.#sibs.clear();
        for (let i = 0; i < this.n; i++) {
            this.#key[i] = this.#rank[i] = this.#p[i] = this.#c[i] = 0;
            this.#mark[i] = false;
        }
    }

    /** Return key of a heap item. */
    key(i) { return this.#key[i]; }

    /** Return ran k of a heap item. */
    rank(i) { return this.#rank[i]; }

    /** Return mark of a heap item. */
    mark(i) { return this.#mark[i]; }

    /** Return parent of a heap item. */
    p(i) { return this.#p[i]; }

    /** Return a child of a heap item. */
    c(i) { return this.#c[i]; }

    /** Set the key of a singleton heap item. */
    setkey(i, k) { assert(this.singleton(i)); this.#key[i] = k; }

    /** Determine if an item is defines a singleton heap.
     *  @param i is a heap item
     *  @return true if it is a singleton.
     */
    singleton(i) {
        return this.#sibs.singleton(i) && this.#p[i] == 0 && this.#c[i] == 0;
    }

    /** Return the item of minimum key in a heap.
     *  @param h is a heap.
     *  @return the item in h that has the smallest key
     */
    findmin(h) { return h; }

    /** Built a heap from a list of singletons.
     *  @param hl is a List object containing singleton items
     *  @param return the heap containing the listed items
     */
    makeheap(hl) {
        let h = hl.first();
        if (h == 0) return 0;
        let minh = h;
        for (let h1 = hl.next(h); h1 != 0; h1 = hl.next(h1)) {
            if (this.key(h1) < this.key(minh)) minh = h1;
            this.#sibs.join(h, h1);
        }
        return minh;
    }

    meld(h1, h2) {
        assert((h1 == 0 || (this.valid(h1) && this.p(h1) == 0)) &&
               (h2 == 0 || (this.valid(h2) && this.p(h2) == 0)));
        if (h1 == 0) return h2;
        if (h2 == 0 || h1 == h2) return h1;
        return (this.key(h1) <= this.key(h2) ? this.#sibs.join(h1, h2) :
                                               this.#sibs.join(h2, h1));
    }

    /** Insert item into a heap. 
     *  @param i is a singleton.
     *  @param h is a heap to which i is inserted.
     *  @param k is the key under which i is inserted
     */
    insert(i, h, k) {
        this.#insertCount++;
        if (i > this.n) this.expand(i);
        this.setkey(i, k); return this.meld(i, h);
    }
    
    /** Decrease the key of an item in a heap.
     *  @param i is an item
     *  @param delta is the amount by which i is to be decreased
     *  @param h is the heap containing i
     *  @return the modified heap
     */
    changekey(i, h, k) {
        this.#changekeyCount++;
        let key = this.#key; let rank = this.#rank; let mark = this.#mark;
        let p = this.#p; let c = this.#c; let sibs = this.#sibs;
        assert(this.valid(i) && this.valid(h) && p[h] == 0);
        if (k > key[i]) {
            h = this.delete(i, h);
            return this.insert(i, (h != 0 ? h : i), k);
        }
        key[i] = k;
        if (p[i] == 0) {
            if (key[h] > key[i]) h = sibs.rotate(h, i);
            return h;
        }
        let pi = p[i];
        if (key[i] >= key[pi]) return h;
        do {
            this.#decreasekeySteps++;
            rank[pi]--;
            c[pi] = sibs.delete(i, c[pi]);
            p[i] = 0; mark[i] = false; h = this.meld(h, i);
            i = pi; pi = p[i];
        } while (mark[i]); // note: if i is marked, it's not a root
        if (pi != 0) mark[i] = true;
    
        return h;
    }

    /** Merge the tree roots in heap, to eliminate repeated ranks.
     *  @param r is a tree root in a heap; all tree roots are assumed
     *  to be non-deleted nodes; also r is the id of the root list in sibs
     *  @return the resulting root with the smallest key
     */
    #mergeRoots(r) {
        let key = this.#key; let rank = this.#rank; let mark = this.#mark;
        let p = this.#p; let c = this.#c; let sibs = this.#sibs;
        let tmpq = this.#tmpq; let rankVec = this.#rankVec;

        assert(this.valid(r) && p[r] == 0);

        // Build queue of roots and find root with smallest key
        let minRoot = r;
        for (let sr = r; sr != 0; sr = sibs.next(sr)) {
            this.#mergeSteps++;
            if (key[sr] < key[minRoot]) minRoot = sr;
            tmpq.enq(sr); p[sr] = 0; mark[sr] = false;
        }
        r = sibs.rotate(r, minRoot); // r is now is min root
        // scan roots, merging trees of equal rank
        let maxRank = -1; // maxRank = maximum rank seen so far
        while (!tmpq.empty()) {
            this.#mergeSteps++;
            let r1 = tmpq.pop();
            assert(rank[r1] <= this.#MAXRANK);
            let r2 = rankVec[rank[r1]];
            if (maxRank < rank[r1]) {
                for (maxRank++; maxRank < rank[r1]; maxRank++)
                    rankVec[maxRank] = 0;
                rankVec[rank[r1]] = r1;
            } else if (r2 == 0) {
                rankVec[rank[r1]] = r1;
            } else if (key[r1] < key[r2] || (key[r1] == key[r2] && r1 == r)) {
                r = sibs.delete(r2, r);
                c[r1] = sibs.join(c[r1], r2);
                rankVec[rank[r1]] = 0;
                rank[r1]++; p[r2] = r1;
                tmpq.enq(r1);
            } else {
                r = sibs.delete(r1, r);
                c[r2] = sibs.join(c[r2], r1);
                rankVec[rank[r1]] = 0;
                rank[r2]++; p[r1] = r2;
                tmpq.enq(r2);
            }
        }
        return r;
    }
        
    /** Remove the item with smallest key from a heap.
     *  @param h is the canonical element of some heap
     *  @return the pair [min, hnew] where min is the deleted item
     *  and hnew is the modified heap
     */
    deletemin(h) {
        this.#deleteCount++;
        let p = this.#p; let c = this.#c; let sibs = this.#sibs;
        assert(this.valid(h) && p[h] == 0);
    
        // Merge h's children into root list and delete it
        // First, make parent pointers of new root nodes 0
        if (c[h] != 0) {
            for (let i = c[h]; i != 0; i = sibs.next(i))
                p[i] = 0;
            sibs.join(h,c[h]); c[h] = 0;
        }
        this.#rank[h] = 0;
        if (sibs.singleton(h)) return [h,0];
        return [h, this.#mergeRoots(sibs.delete(h, h))];
    }
    
    /** Delete an item from a heap.
     *  @param i is an item in some heap
     *  @param h is the heap containing i
     *  @return the heap that results from removing i from h
     */
    delete(i, h) {
        assert(this.valid(i) && this.valid(h) && this.p(h) == 0);
        let k = this.key(i);
        h = decreasekey(i, (this.key(i) - this.key(h)) + 1, h);
        h = deletemin(h);
        this.#key[i] = k;
        return h;
    }
}    
</textarea>

<a id=lheaps><h2>Leftist Heaps</h2></a>

As with Fibobacci heaps, the leftist heaps [Crane72, Knuth73] data structure
maintains a collection of meldable heaps which define a partition over a
common index range $1\ldots n$.
Each heap is identified by one of its items.
In its basic form, the running time of all the standard heap operations
is $O(\log n)$.
<p>
The <i>Javascript</i> implementation includes the following methods.
<ul>
<li>    <code>key(i)</code> returns the key of item <code>i</code>.
<li>    <code>setKey(i,k)</code> sets the key of item <code>i</code>
        to <code>k</code>; item <code>i</code> must define a singleton
        heap.
<li>    <code>findmin(h)</code> returns the item of minimum key in the
        heap identified by item <code>h</code>.
<li>    <code>deletemin(h)</code> returns the item of minimum key in the
        heap identified by <code>h</code> and removes it from
        <code>h</code>.
<li>    <code>meld(h1,h2)</code> combines the two heaps identified by
        <code>h1</code> and <code>h2</code> and returns the identifier of
        the combined heap.
<li>    <code>insert(i,h,k)</code> inserts <code>i</code> into the
        heap identified by <code>h</code> with key <code>k</code>.
<li>    <code>heapify(l)</code> combines the heaps in the list <code>l</code>
        into a single heap.
</ul>
The data structure represents each heap using a heap-ordered binary tree
with a node for each heap item.
Each node includes a <i>left</i> and <i>right</i> pointer and
a <i>rank</i> field.
There is an explicit <i>null</i> node which has a rank of 0;
if a node has no proper left (or right) child, its pointer is directed
to this null node.
For all other nodes, the rank value is one plus the minimum of
the ranks of its two children.
The trees are structured so that the whenever a node's children have
unequal ranks, the node with the larger rank is placed on the left.
This ensures that the shortest path from any tree node to the <i>null</i>
node is the path defined by following right pointers. 
<p>
<div  style="text-align:center;">
<img width="300" src="figs/lheap1.png"><br>
</div>
<p>
The <code>meld</code> operation is implemented by merging the right-most paths
of the two heaps, based on the key values,
then updating the ranks along the merge path, swapping
left and right children as needed to ensure that the larger rank value
is always to the left. This is illustrated below.
<p>
<div  style="text-align:center;">
<img width="700" src="figs/lheap2.png"><br>
</div>
<p>
The <code>insert</code> operation is implemented by treating the item
to be inserted as a single node heap and melding it with the heap it is
to be inserted into.
The <code>deletemin</code> operation is implemented by removing the
root node and melding its two subtrees.
The <code>heapify</code> operation is implemented by
repeatedly removing the first two heaps from the list, melding them
then appending the resulting heap at the end of the list.
It terminates when there is a single heap on the list.
Since the length of the right path from any node to the <i>null</i> node
is at most $\lg n$, the <code>meld</code>, <code>insert</code> and
<code>deletemin</code> operations all take $O(\log n)$ time.
The <code>heapify</code> is a bit more complicated.
The first step is to divide the processing into <i>passes</i>,
where a pass ends when all the heaps on the list at the start of the
pass have been removed and melded with some other heap.
If there are $k$ heaps on the list intially, the number of passes is
at most $\lg k$, since each pass reduces the number of heaps by
a factor of 2. If there are $r$ heaps on the list at the end of
a pass and the heap sizes are $n_1, n_2,\ldots, n_r$, then the time
for the pass is
$$
O \left(\log n_1 + \cdots + \log n_r \right) = O \left( r \log n/r \right)
$$
since the value of the sum is maximized when all heaps are the same size.
Consequently, the total time for <code>heapify</code> is
$$
\begin{eqnarray*}
O\left( \sum_{j=1}^{\lfloor \lg k \rfloor} (k/2^j) \log ( 2^j n/k) \right) &=&
O\left( k \sum_{j=1}^{\lfloor \lg k \rfloor} (j/2^j) + (1/2^j) \log ( n/k) \right) \\
&=& O\left( k\max(1, \log(n/k)) \right)
\end{eqnarray*}
$$

<h3>Lazy Variant</h3>
The basic leftist heap data structure can be extended to include
a <i>lazy deletion</i> operation called <code>retire</code>
and a <i>lazy melding</i> operation.
The <code>retire</code> operation can be implemented by marking the
tree node for an item, but leaving it in place.  
The <code>lazyMeld</code> operation can be implemented similarly,
using a <i>dummy node</i> with a key of minus infinity,
and making the two heaps to be combined, children of this dummy node.
<p>
The presence of retired or dummy nodes means that the
&ldquo;true&rdquo; minimum key node may not be at the root of a heap.
Consequently,
the <code>findmin</code> and <code>deletemin</code> operations must start
with an initial step that traverses the top of the heap, removing all
the retired/dummy nodes that it finds and constructing a list of sub-heaps
for which the roots are not retired or dummy.
This is illustrated below, with retired/dummy nodes shown in yellow.
<p>
<div  style="text-align:center;">
<img width="700" src="figs/lheap3.png"><br>
</div>
This list of heaps is then merged into a single heap using <code>heapify</code>.
<p>
Heap items can also be retired implicitly, using a
a client-provided <i>retired</i> function.
If such a function is provided, it is used to determine if a
node should be considered retired, instead of consulting a stored bit.
This eliminates the time spent marking nodes as retired and
is particularly useful if a single step in an application may make many
heap nodes no longer relevant at the same time. Rather than force the
application to identify and mark each of these nodes, it can be more
efficient to identify them with a function call when it's time to purge
them from the heap-ordered tree.
<p>
The core methods of the <code>LeftistHeaps</code> class are shown below.
<p>
<textarea id="components" rows="20" cols="80" readonly
          style="font-size: 95%;background-color:lightCyan">
export default class LeftistHeaps extends Top {
    #key;          ///< #key[i] is key of item i
    #rank;         ///< #rank[i] gives rank of item i
    #left;         ///< #left[i] is left child of i
    #right;        ///< #right[i] is right child of i

    #dummy;        ///< is first node in list of unused dummy nodes
    #retired;      ///< #retired is either a user-supplied function
                   ///< or an array of bits
    #plist;        ///< temporary list used by purge
    #lazy          ///< when true, implements lazy deletion/melding

    #insertCount;       // calls to insert
    #deleteCount;       // calls to deletemin
    #meldSteps;         // steps in non-lazy meld
    #purgeSteps;        // steps in purge operation

    /** Constructor for LeftistHeaps object.
     *  @param n is index range for object
     *  @parm d is the base of the heap (defaults to 2)
     *  @param capacity is maximum index range (defaults to n)
     *  @param retired is an optional function that if present is used
     *  to determine which nodes are retired.
     */
    constructor(n, capacity=n, lazy=false, retired=null) {
        super(n); 
        if (!capacity) capacity = this.n;
        this.#init(capacity, lazy, retired);
    }

    /** Extend the data structurue to support lazy deletion and melding.
     *  @param retired is an optional function that is used to determine
     *  if a given heap item should be considered retired, or not;
     *  if it is not present, an array of stored bits is used to
     *  distinguish retired items from those that are still active
     */
    makeLazy(retired) {
        let nu = new LeftistHeaps(this.n, this.n, true, retired);
        nu.assign(this); this.xfer(nu);
    }

    /** Revert to initial state. */
    clear() {
        let roots = this.#findRoots();
        for (let r = roots.first(); r != 0; r = roots.next(r)) {
            while (r != 0) [,r] = this.deletemin(r);
        }
    }

    /** Determine if a node is a dummy.
     *  @param i is a node index
     *  @return true if i is a dummy node (possibly in-use)
     */
    isdummy(i) { return this.#lazy && i > this.n; }

    /** Determine if a node is active.
     *  @param i is a node index
     *  @return true if i is neither a dummy, nor a retired item.
     */
    isactive(i) {
        return (!this.#lazy || i <= this.n && !this.retired(i));
    }

    /** Return key of a heap item. */
    key(i) { return this.#key[i]; }

    /** Return rank of a heap item. */
    rank(i) { return this.#rank[i]; }

    /** Return left child of a heap item. */
    left(i) { return this.#left[i]; }

    /** Return a right child of a heap item. */
    right(i) { return this.#right[i]; }

    /** Set the key of a heap item.
     *  @param i is a heap item, assumed to be root of a singleton heap
     *  @param k is new key value for i
     */
    setkey(i, k) { this.#key[i] = k; }

    /** Retire a heap item.
     *  Retired heap items do not belong to any heap and cannot be
     *  used in the future.
     *  @param i is a heap item to be retired.
     */
    retire(i) {
        if (!this.#lazy) this.makeLazy();
        if (Array.isArray(this.#retired)) this.#retired[i] = true;
    }

    /** Determine if a heap item is retired.
     *  @param i is a heap item
     *  @return true if i has been retired (either explicitly or implicitly
     *  through user-provided retired function)
     */
    retired(i) {
        if (!this.#lazy) return false;
        return i <= this.n && (Array.isArray(this.#retired) ?
                                  this.#retired[i] : this.#retired(i));
    }

    /** Meld two heaps.
     *  @param h1 is a heap
     *  @param h2 is a second heap
     *  @return the identifier of the resulyt of melding h1 and h2
     */
    meld(h1, h2) {
        this.#meldSteps++;
        // relies on null node having rank==0
        if (h1 == 0) return h2;
        if (h2 == 0) return h1;
        if (this.key(h1) > this.key(h2)) {
            let h = h1; h1 = h2; h2 = h;
        }
        this.#right[h1] = this.meld(this.right(h1), h2);
        if (this.rank(this.left(h1)) < this.rank(this.right(h1))) {
            let h = this.left(h1);
            this.#left[h1] = this.right(h1);
            this.#right[h1] = h;
        }
        this.#rank[h1] = this.rank(this.right(h1)) + 1;
        return h1;
    }

    /** Insert item into a heap. 
     *  @param i is a singleton.
     *  @param h is a heap to which i is inserted.
     *  @param k is the key under which i is inserted
     */
    insert(i, h, k) {
        this.#insertCount++;
        let mx = Math.max(i, h);
        if (mx > this.n) this.expand(mx);
        assert((i == 0 || this.valid(i)) && (h == 0 || this.valid(h)));
        assert(this.left(i) == 0 && this.right(i) == 0 && this.rank(i) == 1);
        this.setkey(i, k);
        return this.meld(i, h);
    }
    
    /** Return the item of minimum key in a heap.
     *  @param h is a heap.
     *  @return the item in h that has the smallest key
     */
    findmin(h) {
        this.#plist.clear();
        this.#purge(h);
        return this.heapify(this.#plist);
    }

    /** Remove the item with smallest key from a heap.
     *  @param h is a heap
     *  @return the pair [hmin, hnew] where hmin is the deleted
     *  item and hnew is the modified heap
     */
    deletemin(h) {
        this.#deleteCount++;
        let hmin;
        if (this.#lazy) {
            hmin = h = this.findmin(h);
            h = this.lazyMeld(this.left(h), this.right(h));
        } else {
            hmin = h;
            h = this.meld(this.left(h), this.right(h));
        }
        this.#left[hmin] = this.#right[hmin] = 0; this.#rank[hmin] = 1;
        return [hmin,h];
    }


    /** Combine a list of heaps into a single heap.
     *    @param hlist is a List object containing a list of heaps
     *  @param return the root of the combined heap.
     */
    heapify(hlist) {
        if (hlist.empty()) return 0;
        while (hlist.length > 1) {
            let h = this.meld(hlist.at(1), hlist.at(2));
            hlist.deq(); hlist.deq(); hlist.enq(h);
        }
        return hlist.first();
    }

    /** Lazy meld a pair of heaps */
    lazyMeld(h1, h2) {
        if (!this.#lazy) this.makeLazy();
        if (h1 == 0) return h2;
        if (h2 == 0) return h1;
        assert((h1 == 0 || this.valid(h1)) &&
               (h2 == 0 || this.valid(h2)) && this.#dummy != 0);
        let d = this.#dummy; this.#dummy = this.#left[this.#dummy];
        if (this.rank(h1) < this.rank(h2)) {
            let h = h1; h1 = h2; h2 = h;
        }
        this.#left[d] = h1; this.#right[d] = h2;
        this.#rank[d] = this.rank(h2) + 1;
        this.#key[d] = Number.NEGATIVE_INFINITY;
        return d;
    }
}
</textarea>
<p>

<h2>References</h2>
<dt> Crane72
<dd>  &ldquo;Linear lists and priority queues as balanced binary trees,&rdquo;
    by C. A. Crane. Tech. Rep. STANCS-72-259, Computer Science Dept.,
    Stanford Univ., Stanford, CA, 1972.
<dt> FredTarj87
<dd> &ldquo;Fibonacci Heaps and Their Uses in Improved Nework Optimization
    Algorithms,&rdquo; by Michael Fredman and Robert E. Tarjan,
    <i>Journal of the ACM</i>, 1987.
<dt> Knuth73
<dd> <i>The Art of Computer Programming, Vol. 3: Sorting and Searching</i>,
    by D. E. Knuth, AddisonWesley, Reading, MA, 1973
<dt> Tarjan87
<dd> <i>Network Algorithms and Data Structures</i> by Robert E. Tarjan.
     Society for Industrial and Applied Mathematics, 1987.
</dl>
<script src="../googleAnalytics.js"></script>
</body>
</html>
