<html>
<head>
<title>Variations on Edge Coloring</title>
<link type="text/css" rel="stylesheet" href="../../main.css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-41SPK9725S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-41SPK9725S');
</script>
</head>
<body bgcolor=ffffff>
\(
\newcommand{\color}{\textit{color}}
\newcommand{\avail}{\textit{avail}}
\newcommand{\np}{\textit{NP}}

\newcommand{\Proc}{\textbf{procedure}}
\newcommand{\Func}{\textbf{function}}
\newcommand{\flip}{\textit{flip}}
\newcommand{\bmax}{b_{\textit{max}}}

\newcommand{\proof}{\noindent\textit{proof}}

\newcommand{\group}{\textit{group}}
\newcommand{\Input}{\textit{input}}
\newcommand{\output}{\textit{output}}
\newcommand{\hub}{\textit{hub}}
\newcommand{\fanout}{\textit{fanout}}
\newcommand{\groupCount}{\textit{groupCount}}
\newcommand{\firstGroup}{\textit{firstGroup}}
\newcommand{\nextGroup}{\textit{nextGroup}}
\newcommand{\firstGroupAt}{\textit{firstGroupAt}}
\newcommand{\nextGroupAt}{\textit{nextGroupAt}}
\newcommand{\firstInGroup}{\textit{firstInGroup}}
\newcommand{\nextInGroup}{\textit{proof}}
\newcommand{\add}{\textit{add}}
\newcommand{\delete}{\textit{delete}}
\newcommand{\layer}{\textit{layer}}
\newcommand{\firstInLayer}{\textit{firstInLayer}}
\newcommand{\nextInLayer}{\textit{nextInLayer}}
\newcommand{\usage}{\textit{usage}}
\)

<h1>Variations on Edge Coloring<sup>&copy;</sup></h1>

<h2>Bounded Edge Coloring</h2>

The <i>bounded edge coloring problem</i> is a generalization of the
standard edge coloring problem, in which each edge $e$
has a <i>lower bound</i> $b(e)$ on its edge color.
The objective is to find an edge coloring that respects the lower
bounds and that minimizes the largest color assigned to any edge.
If a graph can be colored with colors $\leq C$, it is <i>C-colorable</i> and
$C^\ast(G)$ is defined as the smallest $C$ for which a graph 
$G$ is $C$-colorable.
An example is shown below, where
the first number labelling each edge is its bound, while the second is
a valid color.
<p>
<div  style="text-align:center;">
<img width="23%" src="figs/boundedEdgeColoring.png"><br>
</div>
<p>
The problem is motivated by a scheduling problem in crossbar switches.
In this application, the graph's vertices represent the inputs and
outputs of a crossbar switch, while the edges represent packets to
be transferred from inputs to outputs.
The edge bounds represent the arrival times of the packets
and the colors represent the times at which packets are scheduled for 
transfer.
Since an input can receive at most one packet at each time step,
the bounds on the edges incident to an input must be distinct.
This property is called the <i>unique input bounds condition</i>.
The example below shows a bipartite graph that satisfies the condition.
The tabular representation at right shows the inputs along the
rows and the outputs in the columns.
<p>
<div  style="text-align:center;">
<img width="45%" src="figs/example2.png"><br>
</div>
<p>
The problem was shown to by $\np$-complete in [Turner15b], even when
restricted to bipartite graphs that satisfy the unique
input bounds condition. Consequently, it makes sense to focus
on approximate solutions.
<p>
The crossbar scheduling problem has been studied extensively in the
online context, using several distinct performance criteria.
For so-called <i>input queued</i> switches,
the focus has been on ensuring bounded waiting times in systems
subjected to random input traffic.
Many scheduling algorithms have been shown to meet this 
objective [Leonardi01, Mckeown99a, Mckeown99b].
More compelling, worst-case results have been shown for
<i>combined input and output queued</i>
switches, in which the crossbar is capable of transferring packets
somewhat faster than they can arrive at the inputs, or be transmitted
from the outputs.
Some scheduling algorithms can match the performance of an
idealized <i>output-queued</i>
switch when the crossbar is capable of processing packets
twice as fast as the can arrive at the inputs
[Attiya06, Chuang-99, Krishna-99].

<h3>Lower Bounds</h3>
This section introduces several methods to compute lower bounds on $C^\ast$.
First, a few notations.
For any vertex $u$ in a graph $G$, let $\delta_G(u)$ denote the number of edges incident to $u$
(the vertex degree) and let $\Delta(G)=\max_u \delta_G(u)$.
If $G$ is an instance of the bounded edge coloring problem,
$G_k$ denotes the subgraph defined by the edges with bounds $\leq k$ and
$G^k$ denotes the graph defined by the remaining edges.
<p>
The first lower bound is referred to as the <i>degree bound</i>.
Observe that if a vertex $u$ has $d$ edges with bounds
$\gt c$, then some edge
incident to $u$ must be assigned a color $\geq c+d$.
Consequently, $C^\ast(G) \geq k+\Delta(G^k)$.
The degree bound for $G$ is denoted $D(G)$ and defined by
$D(G)=\max_{k\lt \bmax} k+\Delta(G^k)$,
where $\bmax$ is the largest color bound.
The graph in the previous example has $D=5$ and can be colored using colors
$1,\ldots ,5$. 
Some graphs require more than $D$ colors, as shown below at left
using the tabular format for bipartite graphs.
This graph has $D=4$ but requires five colors and
can be colored with five, as shown at right.
<p>
<div  style="text-align:center;">
<img width="90%" src="figs/example3.png"><br>
</div>
<p>
<p>
The graph in this example is actually a special case of a class of
graphs that require substantially more than $D$ colors.
The graph $B_n$ has inputs $u_1,\ldots,u_n$ and
outputs $v_1,\ldots,v_{2n-1}$.
For $1\leq i\leq n$, $1\leq j \leq i$, there is an
edge $(u_i,v_j)$ with bound $j$, and for each
$1\leq i < n$, $i< j \leq n$, there is an edge $(u_i,v_{n+i})$
with bound $j$. The figure below shows the case of $B_7$, along with
a coloring using nine colors. Note that in general, $D(B_n)=n$.
<p>
<div  style="text-align:center;">
<img width="75%" src="figs/example4.png"><br>
</div>
<p>
A second lower bound can be obtained by computing a sequence of matchings.
Observe that for any $k$, the edges of $G$ that are colored $k$ must
form a matching in $G_k$.
So, if $M_k$ is a maximimum matching in $G_k$,
$E_k$ is the set of edges in $G_k$,
$U_1 = |M_1|$ and $U_k = \min (U_{k-1} + |M_k|, |E_k|)$,
then $U_k$ is an upper bound on the number of edges
that can be colored using colors $\leq k$.
If $U_k$ is smaller than the number of edges in $G$,
then $G$ requires colors larger than $k$.
The <i>matching bound</i> $M(G)$ is defined as the smallest $k$
for which $U_k$ is at least equal to the number of edges in $G$.
For the graph $B_4$ the sequence of matching sizes is $1, 3, 4, 4, 4$
and the sequence of edge counts for $G_k$ is $4, 8, 12, 16, 16$;
consequently, $M=5$.
For the graph $B_7$, the two sequences are
$1,3,5,7,7,7,7,7,7$ and $7, 14,\ldots, 49$, so $M=9$.
It's not difficult to show that
in general, the matching bound for $B_n$ is $\lceil 5n/4 \rceil$.
Note that both the degree bound and the matching bound
can be applied to any graph and any set of edge bounds.
<p>
The third lower bound is based on a property of valid colorings.
Let $G=(V,E)$ be a graph that can be colored using colors $\leq C$.
For $k\leq C$, let $H$ be the subgraph of $G$ induced by edges
with colors $\leq k$  and let $J$ be the subgraph induced by
the remaining edges.
Note that $H$ is a subgraph of $G_k$, $D(H) \leq k$
and $\Delta(J) \leq C-k$.
So, for any $k\leq C$, it is possible to split $G$ into
subgraphs $H$ and $J$ that have these properties.
If a graph $G$ cannot be split in this way for some
$k\leq C$, then $C^\ast(G) > C$.
<p>
For bipartite graphs, one can find a suitable subgraph pair for given
values of $C$ and $k$ by solving a network flow problem.
Let $F$ be a <i>flow graph</i> that includes
a <i>source vertex</i> $s$, a <i>sink vertex</i> $t$ and a chain of vertices
for each vertex in $G_k$.
Specifically, for each input $u$ in $G_k$,
$F$ contains a chain consisting of vertices $u_i$
for each $i\leq k$
and edges $(u_i,u_{i+1})$ with <i>capacity</i> $k-i$.
There is also an edge from $s$ to $u_1$ with capacity $k$.
For each output $v$ in $G_k$,
$F$ contains a chain consisting of vertices $v_i$ for
each $i\leq k$ and edges $(v_{i+1},v_{i})$
with <i>capacity</i> $k-i$.
There is also an edge from $v_1$ to $t$ with capacity $k$.
For each edge $e=(u,v)$ in $G_k$ with bound $i$,
$F$ contains an edge $(u_i,v_i)$ of capacity 1.
This last set of edges is called the <i>core edges</i>.
To complete the construction,
<i>minimum flow requirements</i> are added to the source and sink edges.
In particular, for input $u$ of $G$, the edge $(s,u_1)$
is assigned a minimum flow of $\min \{0,\delta_G(u)-(C - k)\}$.
Similarly, for output $v$ of $G$,
the edge $(v_1,t)$ is assigned a minimum flow of
$\min \{0,\delta_G(v)-(C - k)\}$.
<p>
Note that a valid integer flow defines a subset of the core edges with positive
flow and a subset with zero flow.
The first subset, defines a subgraph of $G_k$ with a degree bound $\leq k$.
If the flow also satifies the minimum
flow requirements, the second subset defines a subgraph with
maximum degree $\leq C-k$. These two subgraphs satisfy the
requirements for the pair $H$ and $J$.
<p>
The following figure shows the graph $B_4$ and the corresponding
flow graph $F$ for $k=2$ and $C=5$.
<p>
<div  style="text-align:center;">
<img width="66%" src="figs/flowBound.png"><br>
</div>
<p>
There is an integer flow for $F$ that
uses the edges that are emphasized in <b>bold</b> and satisfies
all the minimum flow requirements. The edges of $B_4$ that correspond to the
bold core edges are also emphasized in bold. 
These edges define the graph $H$, while the remaining
edges define $J$. Note that $D(H)=2$ and $\Delta(J)=3$.
Also observe that if $C$ were reduced to 4, the lower bounds
on the source edges of $F$ would become 2, making it
impossible to satify the lower bounds.
<p>
The <i>flow bound</i> for $G$ is denoted by $F(G)$ and is defined as the
smallest value of $C$ for which graph $F$ has a flow that satisfies
the minimum flow requirements, for all values of $k\in[1,\bmax]$.
The flow bound for $B_8$ is 11, while the matching bound is 10.
This gap increases for larger graphs. For example, $B_{64}$ has a
matching bound of 80 and a flow bound of 83, while
$B_{256}$ has a matching bound of 320 and a flow bound of 331.
<p>
There is a general method for coloring graphs $B_n$
using colors $1,\ldots,n+\lceil (n-1)/3 \rceil$.
So, for $B_{64}$ the largest color is 85,
for $B_{256}$ the largest color is 341.
The method is illustrated below.
<p>
<div  style="text-align:center;">
<img width="60%" src="figs/colorB.png"><br>
</div>
<p>
The top part of the figure shows the coloring given earlier for $B_7$,
with several regions of the table highlighted. Note that each of the
four highlighted regions uses a distinct set of colors and each color used is
repeated along a diagonal within the region. The edges incident to
the outputs $H,\ldots,M$ are assigned colors equal to their bounds.
The bottom part of the figure shows how the colors of the edges incident to the
first $n$ outputs are assigned in the general case, using a parameter $x=\lceil (n-1)/3 \rceil$.
Again, the table defining the edges is divided into four regions and
disjoint sets of colors are assigned to those regions.
Within each region, colors are used repeatedly
along diagonals.
The edges incident to the last $n-1$ outputs are assigned colors
equal to their bounds. The choice of $x$ ensures that the assignment of colors
to edges yields a legal coloring of the graph that respects all the edge bounds.

<h3>Finding near-optimal colorings</h3>

This section introduces several approximate algorithms for the bounded
edge coloring problem.
Let $G=(V,E)$ be a graph with edge bounds $b(e)$ and let $C^\ast (G)$ be
the largest color value used by an optimal solution.
Let's start with a very simple method that produces solutions with a
maximum color $\leq  2 C^*$.
Using any standard bipartite edge coloring algorithm, the edges can
be colored using colors $\bmax,\ldots,\bmax+\Delta -1$ and since
$C^\ast\geq \max\{\bmax,\Delta\}$,
the largest color used by this solution is $<2C^*$.
<p>
One can get a better approximation by first splitting $G$ into two subgraphs
and coloring the subgraphs separately.
As discussed in the last section, a $C$-colorable graph
can be divided into two subgraphs $H$ and $J$
with $H$ a subgraph of $G_k$, $D(H)\leq k$ and $\Delta(J)\leq C - k$.
For $k\leq \bmax/2$ any such division of $G$
into subgraphs $H$ and $J$ can be used to color $G$ using colors
$\{ k,\ldots,2k-1\} \cup \{ \bmax,\ldots, \bmax + (C-k) -1\}$
using any standard bipartite coloring algorithm to color $H$ and $J$.
Since, the largest color is $\leq \bmax + (C-k) - 1$,
choosing $k=\lfloor \bmax/2 \rfloor$ yields a solution using
colors $\leq \bmax/2 + (C-1)< (3/2) C$.
This also works if $H$ only satisfies the
weaker condition that $\Delta(H)\leq k$.
<p>
One can find the required split of $G$ into $H$ and $J$ using a simpler
variant of the procedure in the last section.
Specifically, it suffices to compute a
$b$-matching on $G$, where for each vertex $u$, the degree range
for $u$ is $[\max(0,\delta(u)-(C-k)),k]$.
The edges in the $b$-matching define $H$ and the remainder define $J$.
One can then use binary search to find the
smallest value of $C$ for which $G$ can be split when
$k=\lfloor \bmax/2 \rfloor$.
This procedure is called the <i>splitting method</i>.
A <i>Javascript</i> implementation appears below.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
export default function becolorSplit(g) {
    let subsets = findSplit(g);
    if (!subsets) throw exception

    let bmax = 0;
    for (let e = g.first(); e; e = g.next(e))
        bmax = Math.max(bmax, g.bound(e));
    let k = ~~(bmax/2);
    let gk = new Graph(g.n,g.edgeRange);
    for (let e = g.first(); e; e = g.next(e)) {
        if (g.bound(e) <= k) gk.join(g.left(e),g.right(e),e);
    }

    let d = new Int32Array(g.n+1);
    for (let u = 1; u <= g.n; u++) d[u] = g.degree(u);
    let dmin = new Int32Array(g.n+1);
    let dmax = new Int32Array(g.n+1).fill(k);
    let [lo,hi] = [Math.max(degreeBound(g),matchBound(g))-1,
                   bmax+g.maxDegree()-1];
    if (hi <= lo) hi = lo+1;
    let H; let C;
    while (lo < hi) {
        // search for largest C for which G cannot be split into H and J
        // cannot split on C=lo, can split on C=hi
        C = ~~((lo + hi + 1)/2);
        for (let u = 1; u <= gk.n; u++)
            dmin[u] = Math.max(0, d[u] - (C-k));
        [H] = bimatchF(gk, subsets, dmin, dmax);
            // H is a Graph object with edges defining subset of g
        for (let u = 1; u <= H.n; u++) {
            if (H.degree(u) < dmin[u]) {
                lo = C; break;
            } else if (u == H.n) {
                hi = C-1; break;
            }
        }
    }
    C = lo+1;  // smallest C for which G can be split
    // compute H and J for final value of C
    for (let u = 1; u <= gk.n; u++)
        dmin[u] = Math.max(0, d[u] - (C-k));
    [H] = bimatchF(gk, subsets, dmin, dmax);
    let J = new Graph(g.n, g.edgeRange);
    for (let e = g.first(); e; e = g.next(e)) {
        if (!H.validEdge(e)) J.join(g.left(e),g.right(e),e);
    }

    // color H and J and transfer results to color for g
    let color = new Int32Array(g.edgeRange+1);
    let [colorH] = ecolorG(H);
    for (let e = H.first(); e; e = H.next(e)) 
        color[e] = (k-1) + colorH[e];
    let [colorJ] = ecolorG(J);
    for (let e = J.first(); e; e = J.next(e)) 
        color[e] = (bmax-1) + colorJ[e];

    return [color];
}
</textarea><p>
This can be demonstrated with this script.
<p> <pre style="padding-left:5%">
let g = hardCase(7); 
let [color,ts] = becolorSplit(g,1);
log(ts); log('C=' + Math.max(...color));
</pre> <p>
This yields the result below.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
{
a[h:1/7 o:2/5. o:3/4. o:4/11 o:5/8 o:6/12 o:7/9]
b[h:1/3. i:2/10 p:3/4. p:4/8 p:5/11 p:6/9 p:7/12]
c[h:1/5. i:2/7 j:3/3. q:4/11 q:5/8 q:6/12 q:7/9]
d[h:1/4. i:2/9 j:3/5. k:4/10 r:5/11 r:6/8 r:7/12]
e[h:1/12 i:2/3. j:3/4. k:4/7 l:5/9 s:6/11 s:7/8]
f[h:1/9 i:2/5. j:3/7 k:4/12 l:5/11 m:6/8 t:7/10]
g[h:1/10 i:2/4. j:3/12 k:4/9 l:5/8 m:6/11 n:7/7]
h[a:1/7 b:1/3. c:1/5. d:1/4. e:1/12 f:1/9 g:1/10]
i[b:2/10 c:2/7 d:2/9 e:2/3. f:2/5. g:2/4.]
j[c:3/3. d:3/5. e:3/4. f:3/7 g:3/12]
k[d:4/10 e:4/7 f:4/12 g:4/9]
l[e:5/9 f:5/11 g:5/8]
m[f:6/8 g:6/11]
n[g:7/7]
o[a:2/5. a:3/4. a:4/11 a:5/8 a:6/12 a:7/9]
p[b:3/4. b:4/8 b:5/11 b:6/9 b:7/12]
q[c:4/11 c:5/8 c:6/12 c:7/9]
r[d:5/11 d:6/8 d:7/12]
s[e:6/11 e:7/8]
t[f:7/10]
} 

C=12
</textarea><p>
The trace string shows the graph $B_7$ with edge bounds
and the colors assigned by the split algorithm.
A period is included for each edge in the subgraph $H$.
The statistics object shows the largest color assigned
by the algorithm and the three lower bounds (degree, match, flow).
<p>
Next are two algorithms that color the graph by
constructing a series of disjoint matchings in $G_1, G_2, \ldots$
coloring the edges in each matching with colors $1,2,\ldots$ and
stopping when all edges in $G$ have been colored.
The first constructs matchings in the uncolored subgraphs of $G_k$,
that have maximum degree in the subgraph and maximum size.
The second constructs priority matchings in the uncolored subgraphs of $G_k$
with highest priority assigned to the vertices of maximum degree in the
uncolored subgraph of $G$ (<i>not</i> $G_k$).
The first is called the <i>maximum degree matching</i> algorithm,
while the second is called the <i>priority matching</i> algorithm.
A <i>Javascript</i> implementation of the first algorithm appears below.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
export default function becolorMdmatch(g) {
    let color = new Int32Array(g.edgeRange+1);
    let gc = new Graph(g.n,g.edgeRange);
        // subgraph of uncolored edges with bounds <= c
    let c;
    let count = 0;  // number of edges colored so far
    for (c = 1; count < g.m; c++) {
        // add edges with bound of c to gc
        for (let e = g.first(); e; e = g.next(e)) {
            if (c >= g.bound(e) && c < g.bound(e) + 1)
                gc.join(g.left(e), g.right(e), e);
        }
        // find max degree matching in gc, extended to max size
        let [match] = mdmatchG(gc);
        [match] = bimatchHK(gc,match)
        for (let e = match.first(); e; e = match.next(e)) {
            color[e] = c; gc.delete(e); count++;
        }
    }
    return [color];
}
</textarea><p>
The priority matching algorithm appears below.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
export default function becolorPmatch(g) {
    // compute degrees in g and assign initial priorities
    let d = new Int32Array(g.n+1);
    for (let u = 1; u <= g.n; u++) d[u] = g.degree(u);
    let maxd = Math.max(...d);
    let prio = new Int32Array(g.n+1);
    for (let u = 1; u <= g.n; u++)
        prio[u] = (d[u] == maxd ? 2 : 1);

    let color = new Int32Array(g.edgeRange+1);
    let gc = new Graph(g.n,g.edgeRange);
        // subgraph of uncolored edges with bounds <= c
    let c;
    let count = 0;  // number of edges colored so far
    for (c = 1; count < g.m; c++) {
        // add edges with bound of c to gc
        for (let e = g.first(); e; e = g.next(e)) {
            if (c >= g.bound(e) && c < g.bound(e) + 1)
                gc.join(g.left(e), g.right(e), e);
        }
        // find matching in gc that colors all vertices with max
        // degree in uncolored subgraph; extend to max size matching
        let [match,,mstats] = pbimatchHKT(gc,prio);
        for (let e = match.first(); e; e = match.next(e)) {
            color[e] = c; gc.delete(e); count++;
            d[g.left(e)]--; d[g.right(e)]--;
        }
        // update priorities
        maxd = Math.max(...d);
        for (let u = 1; u <= g.n; u++) prio[u] = (d[u] == maxd ? 2 : 1);
    }
    return [color];
}
</textarea><p>
Adjusting the previous script yields the following output for
the maximum degree matching algorithm.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
{
a[h:1 o:2 o:3 o:4 o:5 o:6 o:7]
b[h:1 i:2 p:3 p:4 p:5 p:6 p:7]
c[h:1 i:2 j:3 q:4 q:5 q:6 q:7]
d[h:1 i:2 j:3 k:4 r:5 r:6 r:7]
e[h:1 i:2 j:3 k:4 l:5 s:6 s:7]
f[h:1 i:2 j:3 k:4 l:5 m:6 t:7]
g[h:1 i:2 j:3 k:4 l:5 m:6 n:7]
h[a:1 b:1 c:1 d:1 e:1 f:1 g:1]
i[b:2 c:2 d:2 e:2 f:2 g:2]
j[c:3 d:3 e:3 f:3 g:3]
k[d:4 e:4 f:4 g:4]
l[e:5 f:5 g:5]
m[f:6 g:6]
n[g:7]
o[a:2 a:3 a:4 a:5 a:6 a:7]
p[b:3 b:4 b:5 b:6 b:7]
q[c:4 c:5 c:6 c:7]
r[d:5 d:6 d:7]
s[e:6 e:7]
t[f:7]
}

1: [ah]
2: [bh ci ao]
3: [ch dj ao bp ei]
4: [gi ek ao bp cq fj dh]
5: [fh gj ao bi cq dk el]
6: [fi gh ao bp cj dr es]
7: [fk gl ao bp cq di eh]
8: [fl gk bp cq dr ej]
9: [fm gn dr es]
10: [ft gm]

{
a[h:1/1 o:2/2 o:3/3 o:4/4 o:5/5 o:6/6 o:7/7]
b[h:1/2 i:2/5 p:3/3 p:4/4 p:5/6 p:6/7 p:7/8]
c[h:1/3 i:2/2 j:3/6 q:4/4 q:5/5 q:6/7 q:7/8]
d[h:1/4 i:2/7 j:3/3 k:4/5 r:5/6 r:6/8 r:7/9]
e[h:1/7 i:2/3 j:3/8 k:4/4 l:5/5 s:6/6 s:7/9]
f[h:1/5 i:2/6 j:3/4 k:4/7 l:5/8 m:6/9 t:7/10]
g[h:1/6 i:2/4 j:3/5 k:4/8 l:5/7 m:6/10 n:7/9]
h[a:1/1 b:1/2 c:1/3 d:1/4 e:1/7 f:1/5 g:1/6]
i[b:2/5 c:2/2 d:2/7 e:2/3 f:2/6 g:2/4]
j[c:3/6 d:3/3 e:3/8 f:3/4 g:3/5]
k[d:4/5 e:4/4 f:4/7 g:4/8]
l[e:5/5 f:5/8 g:5/7]
m[f:6/9 g:6/10]
n[g:7/9]
o[a:2/2 a:3/3 a:4/4 a:5/5 a:6/6 a:7/7]
p[b:3/3 b:4/4 b:5/6 b:6/7 b:7/8]
q[c:4/4 c:5/5 c:6/7 c:7/8]
r[d:5/6 d:6/8 d:7/9]
s[e:6/6 e:7/9]
t[f:7/10]
}
 
C=10
</textarea><p>
<p>
In this case, the trace string shows the matching computed
for each color, as it's computed.
The trace string produced by the priority matching algorithm is similar.
<p>
Note that the priority matching algorithm can be implemented with just
two priority classes, as shown here.
Alternatively, one can let the vertex priority equal the degree
in the uncolored subgraph. This occasionally out-performs the
simpler version.
Also note that both matching algorithms can be implemented to work
on general graphs, not just bipartite graphs.
<p>
No worst-case bound is known for the two matching
algorithms, but experiments demonstrate that the priority matching
algorithm can produce solutions that closely track the best lower bounds.

<h3>Experimental Evaluation</h3>
The following script can be used to evaluate the algorithms on graphs $B_n$.
<p> <pre style="padding-left:5%">
let n = 8; let g = hardCase(n);
let [color,ts,stats] = becolorSplit(g);
log(`B_${n} split  C=${stats.C} flowBound=${flowBound(g)}`);
</pre>
Sample results are shown below.
<p> <pre style="padding-left:5%">
B_8  split   C= 13 flowBound=11 
B_16 split   C= 27 flowBound=21 
B_32 split   C= 55 flowBound=42 
B_64 split   C=111 flowBound=83 

B_8  mdmatch C= 12 flowBound=11 
B_16 mdmatch C= 24 flowBound=21 
B_32 mdmatch C= 48 flowBound=42 
B_64 mdmatch C= 96 flowBound=83

B_8  pmatch  C= 11 flowBound=11
B_16 pmatch  C= 22 flowBound=21 
B_32 pmatch  C= 42 flowBound=42 
B_64 pmatch  C= 84 flowBound=83
</pre>
The max degree matching algorithm produces colorings with about $(3/2)n$ colors.
The priority matching algorithm closely tracks
the flow lower bound and for the larger cases,
its largest color is less than $n+\lceil (n-1)/3 \rceil$.
The following script can be used to evaluate the algorithms'
performance on random graphs.
<p> <pre style="padding-left:5%">
let n = 64; let d = 4;
let g = randomCase(n,d);
let [color,ts,stats] = becolorSplit(g);
log(`random(${n},${d}) split   C=${stats.C} ` + 
   `matchBound=${matchBound(g)} flowBound=${flowBound(g)}`);
</pre> <p>
Sample output appears below.
<p> <pre style="padding-left:5%">
random(64, 4) split   C= 7 matchBound= 5 flowBound= 6 
random(64, 8) split   C=15 matchBound= 9 flowBound=11 
random(64,16) split   C=28 matchBound=17 flowBound=22 
random(64,32) split   C=53 matchBound=33 flowBound=40 

random(64, 4) mdmatch C= 6 matchBound= 5 flowBound= 6 
random(64, 8) mdmatch C=12 matchBound= 9 flowBound=12 
random(64,16) mdmatch C=21 matchBound=17 flowBound=21 
random(64,32) mdmatch C=40 matchBound=33 flowBound=40 

random(64, 4) pmatch  C= 6 matchBound= 5 flowBound= 6 
random(64, 8) pmatch  C=11 matchBound= 9 flowBound=11 
random(64,16) pmatch  C=22 matchBound=17 flowBound=22 
random(64,32) pmatch  C=40 matchBound=33 flowBound=40 
</pre>
Note that in this case, the results for both matching algorithms
are identical to the flow lower bound in all cases.
<p>
In the crossbar scheduling context, one is often interested in
how the system performs when the crossbar is able to process
packets at a faster rate than they arrive. The ratio of the
crossbar processing rate to the maximum packet arrival rate
is called the <i>speed advantage</i> or <i>speedup</i>,
and is typically chosen to enable the system to keep up with the
arriving traffic under all conditions.
<p>
In a system with a speedup larger than 1, packet arrivals occur
at non-integer time instants. So for example, with a speedup of 1.5,
packets could arrive at times $1, 2.5, 4, 5.5,\ldots$.
Since the system can only process them at integer time instants,
these non-integer arrival times can be rounded up to $1,3,4,6,\ldots$.
So one can emulate a system with a speedup by constraining the
edge bounds so that they correspond to the times when arriving packets
can be processed.
The following script can be used to examine the effect of
speedups $>1$.

<p> <pre style="padding-left:5%">
let n = 64; let speedup = 1.5;
let g = hardCase(n, speedup);
let [color,ts,stats] = becolorMdmatch(g);
log(`B_${n} speedup=${speedup} mdmatch C=${stats.C} ` +
    `degreeBound=${degreeBound(g)} flowBound=${flowBound(g)}`);
</pre>
Results for $B_n$ appear below.
<p> <pre style="padding-left:5%">
B_64 speedup=1   mdmatch C= 96 degreeBound= 64 flowBound= 83 
B_64 speedup=1.2 mdmatch C= 99 degreeBound= 77 flowBound= 88 
B_64 speedup=1.4 mdmatch C=108 degreeBound= 90 flowBound= 92 
B_64 speedup=1.6 mdmatch C=115 degreeBound=102 flowBound=102 
B_64 speedup=1.7 mdmatch C=118 degreeBound=109 flowBound=109 
B_64 speedup=1.8 mdmatch C=121 degreeBound=115 flowBound=115 
B_64 speedup=2   mdmatch C=127 degreeBound=127 flowBound=127 

B_64 speedup=1   pmatch  C= 84 degreeBound= 64 flowBound= 83 
B_64 speedup=1.2 pmatch  C= 89 degreeBound= 77 flowBound= 88 
B_64 speedup=1.4 pmatch  C= 93 degreeBound= 90 flowBound= 92 
B_64 speedup=1.6 pmatch  C=103 degreeBound=102 flowBound=102 
B_64 speedup=1.7 pmatch  C=109 degreeBound=109 flowBound=109 
B_64 speedup=1.8 pmatch  C=115 degreeBound=115 flowBound=115 
B_64 speedup=2   pmatch  C=127 degreeBound=127 flowBound=127 
</pre>
Observe that as the speedup increases, the gap between the largest
color used and the lower bounds drops to zero, with the priority
matching algorithm closing the gap for speedups of 1.7 or more.

<h2>Edge Group Coloring</h2>

An instance of the <i>edge group coloring</i> problem is an
undirected graph and a partition of its edges into groups,
where the edges forming each group all share
a common endpoint, called the <i>hub</i> of the group.
The number of edges in a group is called its <i>fanout</i>.
A coloring is a function, from the edges to the positive integers,
that assigns different values to pairs of edges that share a common
endpoint and belong to different edge groups.
The objective is to find a coloring that uses the
smallest possible number of distinct colors.
An example is shown below.
<p>
<div  style="text-align:center;">
<img width="25%" src="figs/egcExample1.png"><br>
</div>
<p>
Edge groups are shown by using arcs joining the edges belonging to
a common group.
So in this example, edges $\{b,e\}$, $\{c,e\}$ and $\{d,e\}$ form a group of
size 3 with hub $e$.
The numbers on the edges represent a valid coloring.
<p>
Edge group coloring was defined in [Turner15c] as an abstraction of
the multicast crossbar scheduling problem [PMA97] and the
problem of constructing efficient
&ldquo;generalized connnectors&rdquo; [KKP85,YM91].
In these contexts, the graphs of interest are bipartite and have
edge groups with hubs that are &ldquo;inputs&rdquo; as illustrated
in the example below.
<p>
<div  style="text-align:center;">
<img width="60%" src="figs/egcExample2.png"><br>
</div>
<p>
In the tabular representation at right, the edge groups are shown as
connected circles, representing the edges in the group. The numbers
labeling the edges are their colors.
It's worth noting that Kirkpatrick, Klawe and Pippenger [KKP85] formulated
the problem of constructing generalized connnectors
as a hypergraph coloring problem, which is equivalent to the slightly
simpler formulation used here.
<p>
The problem is $NP$-complete even for bipartite graphs,
but there are several approaches
that can produce practically useful approximation algorithms.
There are also some simple bounds that can be helpful.
The maximum vertex degree $\Delta$ of a graph $G$ provides an upper bound
on the number of colors needed to color it and there is also a simple
lower bound.
Let $\Delta_o$ be the maximum vertex degree at the outputs of $G$,
and let $\Gamma_i$ be the maximum number of groups present at an input.
Then any coloring must use at least $\max \{\Gamma_i, \Delta_o\}$ colors.

<h3>Layering Method</h3>

Let $G$ be a bipartite graph for which the edges have been divided into
groups with hubs at the inputs.
Let $L$ be a subset of the groups, with no two groups in $L$ sharing a hub,
and let $G_L$ be the subgraph of $G$ defined by the edges in $L$.
Then, any coloring of $G_L$ is constrained only by the outputs.
Consequently, one can color $G_L$ with $\Delta_o(G_L)$ colors.
This leads to a general approach to coloring a graph,
first described in [Turner15c].
<p>
In the first step, the edge groups are partititioned so that each
subset contains groups with distinct hubs.
Each of these subsets is referred to as a <i>layer</i> and the
maximum output degree of the subgraph defined by a layer is referred
to as its <i>thickness</i>.
The subgraphs defined by the layers can be colored separately,
using distinct color sets.
Combining these colorings yields a coloring for $G$ where the number
of colors is the sum of the layer thicknesses.
<p>
As an example, consider the graph and edge groups defined as shown below.
<p> <pre style="padding-left:5%">
a[(f i l) (g k) (e)]
b[(i l) (h j) (g k)]
c[(f h j) (e) (g h)]
d[(f i) (e j) (k l)]
</pre>
Here, each line shows an input, with its adjacent outputs,
divided into groups. The simplest way to partition the groups into
layers is to simply assign the $i$-th group at each input to the
$i$-th layer, as shown below.
<p> <pre style="padding-left:5%">
[a(f i l) b(i l) c(f h j) d(f i)]
[a(g k) b(h j) c(e) d(e j)]
[a(e) b(g k) c(g h) d(k l)]
</pre>
Each line shows the groups in a layer.
These layers have thicknesses $[3, 2, 2]$, so can be colored with 7 colors.
The alternate layer division shown below has layer thicknesses $[1, 2, 2]$,
so can be colored with five colors.
<p> <pre style="padding-left:5%">
[a(g k) b(h j) c(e) d(f i)] 
[a(f i l) b(g k) c(g h) d(e j)] 
[a(e) b(i l) c(f h j) d(k l)]
</pre>
Better colorings can often be obtained by relaxing the constraint that
edges in different layers use disjoint color sets.
One method colors each layer $l$ by letting color $c=1$ and repeating
the following step until all edges in $l$ are colored.
<p style="padding-left:5%">
For each group $g$ in $l$ with at least one uncolored edge,
use $c$ to color every uncolored edge in $g$ for which $c$ is a viable color.
Increment $c$.
<p>
When this procedure is applied to the second division into layers,
it produces the 4-coloring shown below.
<p> <pre style="padding-left:5%">
1[a(g k) b(h j) c(e) d(f i)]
2[a(f i l) b(g k) c(. h) d(e j)]
3[c(g .) a(e) b(i l) d(k .)]
4[c(f h j) d(. l)]
</pre>
Here, each line shows the edge groups (and partial groups) that
are assigned the same color. Groups that are assigned more than
one color are shown on multiple lines,
using periods to indicate edges assigned
colors on other lines.
<p>
In general, it is advantageous to start with a division into
layers that are as &ldquo;thin&rdquo; as possible.
One natural heuristic first creates a partial layering, by assigning
the $\Gamma_i$ groups at some input to different layers, then extending
the partial layering by assigning each group in a way that avoids increasing
the thickness of the layer it's assigned to whenever possible.
The <i>Javascript</i> program shown below uses this approach to construct
the layers and optionally uses the &ldquo;relaxed&rdquo; coloring method
described above.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
let eg;        // shared reference to EdgeGroups object
let egl;    // shared reference to EdgeGroupLayers object

export default function egcT1(eg0, strict=false) {
    eg = eg0;

    let Gamma_i = maxGroupCount(eg);
    let Delta_o = maxOutDegree(eg);
    let Cmin = lowerBound(Gamma_i, Delta_o);

    egl = new EdgeGroupLayers(eg,Gamma_i);
    buildLayers(Gamma_i);

    let thickness = new Int32Array(Gamma_i+1);
    for (let l = 1; l <= egl.n_l; l++)
        thickness[l] = egl.layerThickness(l);
    let totalThickness = thickness.reduce((sum, v) => sum + v, 0);
    let maxThickness = Math.max(...thickness);

    let egc = color(thickness, strict);
    let C = egc.maxColor();

    return [egc ..];
}

/** Assign groups to layers, while trying to minimize the maximum
 *  layer thickness.
 *  @param Gamma_i is the maximum groupCount of any vertex.
 */
function buildLayers(Gamma_i) {
    let ocount = new Array(Gamma_i+1);
    let u = 1; while (eg.groupCount(u) < Gamma_i) u++;
    let l = 1;
    for (let g = eg.firstGroupAt(u); g; g = eg.nextGroupAt(u,g)) {
        egl.add(g,l);
        ocount[l] = new Int32Array(eg.graph.n+1);
        for (let e = eg.firstInGroup(g); e; e = eg.nextInGroup(g,e))
            ocount[l][eg.output(e)]++;
        ocount[l][0] = Math.max(...ocount[l]);  // layer thickness
        l++;
    }

    eg.sortAllGroups();
    for (let g = eg.firstGroup(); g; g = eg.nextGroup(g)) {
        if (egl.layer(g)) continue;
        let bestThin = 0; let thinConflicts = 0;
        let bestThick = 0; let thickConflicts = 0;
        
        for (let l = 1; l <= Gamma_i; l++) {
            // if l contains a group with same hub as g, go on to next layer
            let skip = 0; let u = eg.hub(g);
            for (let gl = egl.firstInLayer(l); gl; gl = egl.nextInLayer(l,gl)) {
                if (eg.hub(gl) == u) { skip = 1; break; }
            }
            if (skip) continue;

            // count output conflicts of g with groups in l and determine
            // if g conflicts with a "thick" output
            let conflicts = 0; let gthick = 0;
            for (let e = eg.firstInGroup(g); e; e = eg.nextInGroup(g,e)) {
                let v = eg.output(e);
                if (ocount[l][v] > 0) {
                    conflicts++;
                    if (ocount[l][v] == ocount[l][0])
                        gthick = 1;
                }
            }
            // update bestThick or bestThin as appropriate
            if (gthick) {
                if (bestThick == 0 || conflicts < thickConflicts) {
                    bestThick = l; thickConflicts = conflicts;
                }
            } else {
                if (bestThin == 0 || conflicts < thinConflicts) {
                    bestThin = l; thinConflicts = conflicts;
                }
            }
        }
        let best = (bestThin ? bestThin : bestThick);
        if (best == 0) break;
        egl.add(g, best);
        for (let e = eg.firstInGroup(g); e; e = eg.nextInGroup(g,e)) {
            let v = eg.output(e);
            ocount[best][v]++;
            if (ocount[best][v] > ocount[best][0]) ocount[best][0]++;
        }
    }
}

/** Color the edges by layer.
 *  @param thickness is array of thickness values by layer
 *  @param strict is a flag which enforces disjoint color sets for each layer
 *  @return an EdgeGroupColors object
 */
function color(thickness, strict) {
    // create object to record colors in
    let totalThickness = thickness.reduce((sum,val)=>sum+val, 0);
    let egc = new EdgeGroupColors(eg, totalThickness);

    // for each layer, color edges with smallest available color
    let lastColor = 0;  // used for strict case
    for (let l = 1; l <= egl.n_l; l++) {
        let fc = strict ? lastColor+1 : 1;
        for (let c = fc; c <= lastColor + thickness[l]; c++) {
            for (let g = egl.firstInLayer(l); g; g = egl.nextInLayer(l,g)) {
                for (let e = eg.firstInGroup(g); e; e = eg.nextInGroup(g,e)) {
                    if (!egc.color(e) && egc.avail(c,e))
                        egc.color(e,c);
                }
            }
        }
        lastColor += thickness[l];
    }
    return egc;
}
</textarea><p>
The <i>strict</i> argument to <i>egcT1</i> is used to
force the layers to use disjoint color sets. By default, the color sets
are allowed to overlap.
<p>
The implementation uses three data structures.
The <i>edge groups</i> data structure maintains the structure of
the edge groups and includes the following methods.
<ul>
<li> $\group(e)$ returns the group that contains edge $e$.
<li> $\Input(e)$ returns the endpoint of $e$ in the input set.
<li> $\output(e)$ returns the endpoint of $e$ in the output set.
<li> $\hub(g)$ returns the input at the hub of group $g$.
<li> $\fanout(g)$ returns the number of outputs in group $g$.
<li> $\groupCount(u)$ returns the number of groups at input $u$.
<li> $\firstGroup()$ returns the first group in the list of groups.
<li> $\nextGroup(g)$ returns the next group in the list following $g$.
<li> $\firstGroupAt(u)$ returns the first group in the list of groups
    at input $u$.
<li> $\nextGroupAt(u,g)$ returns the next group in the list at u
    following $g$.
<li> $\firstInGroup(g)$ returns the first edge in group $g$.
<li> $\nextInGroup(g,e)$ returns the next edge in $g$ following $e$.
<li> $\add(e,g)$ adds an unassigned edge $e$ to a group $g$.
<li> $\delete(e)$ from its group.
</ul>
The <i>edge group layers</i> data structure maintains the structure of
the layers and includes the following methods.
<ul>
<li> $\layer(g)$ returns the layer containing group $g$.
<li> $\firstInLayer(l)$ returns the first group in layer $l$.
<li> $\nextInLayer(l,g)$ returns the first group in layer $l$
    following $g$.
<li> $\add(g,l)$ adds group $g$ to layer $l$.
<li> $\delete(g)$ deletes group $g$ from its assigned layer.
</ul>
The <i>edge group colors</i> data structure maintains the edge group
coloring and includes the following methods.
<ul>
<li> $\usage(c,v)$ returns the number of times color $c$ is used
    at vertex $v$.
<li> $\avail(c,e)$ returns true if $c$ is a color that can be used
    for edge $e$.
<li> $\color(e,c)$ returns the color of edge $e$ and if the second
    argument is present, it first assigns color $c$ to $e$.
</ul>
The <i>buildLayers</i> method starts by finding an input with
$\Gamma_i$ groups, and assigns these groups to distinct layers,
giving a partial layering.
It then assigns the remaining groups to layers in decreasing order of their
fanouts.
An output $v$ is said to be <i>bound</i> in a layer $l$ if one or more
of $l$'s groups contains $v$.
An output $v$ is said to be <i>thick</i> in $l$ if the number
of groups in $l$ that include $v$ is the largest for any output.
A layer $l$ is thick with respect to a group $g$ not in $l$ if
$g$ includes a thick output in $l$;
otherwise, $l$ is <i>thin</i> with respect to $g$.
Each group $g$ is assigned to a layer using the following procedure.
<p style="padding-left:5%">
If every layer is thick with respect to $g$, then $g$ is assigned to
a layer with the smallest thickness.
Otherwise, it is assigned to a thin layer with the smallest thickness.
<p>
The following script can be used to demonstrate <i>egcT1</i>.
<p> <pre style="padding-left:5%">
let eg = new EdgeGroups();
eg.fromString('{a[(e k o p) (f g j m) (l)] b[(e n o p) (h k) (m i l)] ' +
              'c[(f) (h k g j m) (i l n)] d[(e i o p) (f g h) (j n)]}');
let [egc,ts] = egcT1(eg,0,1);
log(ts);
</pre> <p>
Here is the resulting output.
<p> <pre style="padding-left:5%">
graph: {
a[(e k o p) (f g j m) (l)]
b[(e n o p) (h k) (m i l)]
c[(f) (h k g j m) (i l n)]
d[(e i o p) (f g h) (j n)]
}

layers:
{
[a(e k o p) b(m i l) d(f g h) c(f)]
[a(f g j m) b(e n o p) c(i l n) d(j n)]
[a(l) c(h k g j m) d(e i o p) b(h k)]
}
[2,3,2]

colors: {
1[a(e k o p) b(m i l) d(f g h) c(. . n)]
2[c(f) a(. g j m) b(e n o p) d(. i . .)]
3[a(f . . .) c(i l .) d(j n) b(h k)]
4[a(l) c(h k g j m) d(e . o p)]
}
</pre> <p>
The layers are shown on separate lines and are followed
by the layer thicknesses.
The colors assigned to the groups are shown using the format
introduced earlier. In this case, three of the groups required
two colors each.
<p>
The following script can be used to investigate the performance
of the algorithm.
<p> <pre style="padding-left:5%">
let n_i = 40; let n_o = 8*n_i; let Gamma_i = 20; let Delta_o = Gamma_i;
let Cmin = Math.max(Gamma_i,Delta_o); let X = 22;

let eg = egcRandomCase(n_i, Gamma_i, n_o, Delta_o, X);
let t = Date.now(); let [egc,,stats] = egcT1(eg); t = Date.now() - t;
log(`io=(${n_i},${n_o}) GD=(${Gamma_i},${Delta_o}) X=${X} :: ` +
    `C=${stats.C} R=${stats.R} T=${stats.thickness} ${t}ms`);
</pre> <p>
The function call $\textit{egcRandomCase}(n_i, \Gamma_i, n_o, \Delta_o, X)$
starts by generating a random regular bipartite graph,
with $n_i$ inputs and $n_o$ outputs.
The outputs have degree $\Delta_o$.
For each output, it assigns distinct random colors between 1 and
$X$ to the incident edges.
At each input it then forms groups from all the
edges assigned the same color.
For inputs that have more than $\Gamma_i$ groups, it merges pairs
of groups until the number of groups per input does not exceed $\Gamma_i$.
It then discards the random coloring.
<p>
Note that this ensures that there is a proper edge group coloring with
$X$ colors and that every proper coloring must have at least
$C_{\textit{min}}=\min(\Gamma_i,\Delta_o)$ colors.
The sample runs below show the effect of increasing the asymmetry between
inputs and outputs.
<p> <pre style="padding-left:5%">
io=(40,  40) GD=(20,20) X=22 :: C=22 R=1.10 T=35  2ms 
io=(40,  80) GD=(20,20) X=22 :: C=27 R=1.35 T=38  3ms 
io=(40, 160) GD=(20,20) X=22 :: C=32 R=1.60 T=48 10ms 
io=(40, 320) GD=(20,20) X=22 :: C=39 R=1.95 T=59 11ms 
io=(40, 640) GD=(20,20) X=22 :: C=46 R=2.30 T=68 25ms 
io=(40,1280) GD=(20,20) X=22 :: C=51 R=2.55 T=78 48ms 
</pre> <p>
Here, the pair <i>io</i> is the number of inputs and outputs,
<i>GD</i> is the pair $(\Gamma_i,\Delta_o)$
and $X$ is the upper bound on the number of colors required.
$C$ is the number of colors used by the algorithm,
$R$ is the performance ratio and $T$ the total thickness
of the layers.
Each doubling of the input/output asymmetry leads to an incremental increase
in the performance ratio, suggesting that the performance ratio is roughly
logarithmic in the asymmetry.
The next set of results shows how the performance ratio
varies with the ratio of $\Gamma_i$ to $\Delta_o$.
<p> <pre style="padding-left:5%">
io=(40,320) GD=( 5,20) X=22 :: C=27 R=1.35 T=41 7ms 
io=(40,320) GD=(10,20) X=22 :: C=33 R=1.65 T=48 9ms 
io=(40,320) GD=(15,20) X=22 :: C=36 R=1.80 T=57 9ms 
io=(40,320) GD=(20,20) X=22 :: C=39 R=1.95 T=59 10ms 
io=(40,320) GD=(20,15) X=22 :: C=32 R=1.60 T=45 8ms 
io=(40,320) GD=(20,10) X=22 :: C=24 R=1.20 T=33 6ms 
io=(40,320) GD=(20, 5) X=22 :: C=20 R=1.00 T=20 7ms 
</pre> <p>
Observe that the number of colors (and hence, the performance ratio)
is maximized when $\Gamma_i=\Delta_o$.
When $\Gamma_i$ is reduced, relative to $\Delta_o$, the edge colors are
less constrained, reducing the number required.
When $\Delta_o$ is reduced relative to $\Gamma_i$, the number of edges
per group drops, again reducing the number of colors needed.
<p>
The next set of results shows the effect of the graph density.
<p> <pre style="padding-left:5%">
io=(40,320) GD=( 2, 2) X= 3 :: C= 4 R=2.00 T= 4  1ms 
io=(40,320) GD=( 4, 4) X= 5 :: C= 9 R=2.25 T=12  3ms 
io=(40,320) GD=( 8, 8) X= 9 :: C=17 R=2.13 T=24  2ms 
io=(40,320) GD=(12,12) X=14 :: C=24 R=2.00 T=36  8ms 
io=(40,320) GD=(16,16) X=18 :: C=32 R=2.00 T=46 10ms 
io=(40,320) GD=(20,20) X=22 :: C=39 R=1.95 T=59  9ms 
</pre> <p>
Here, the number of colors used grows directly with the
density and the lower bound, so the performance ratio changes
very little.
<p>
The final set of set of results shows how the performance
is affected by the choice of $X$. 
<p> <pre style="padding-left:5%">
io=(40,320) GD=(20,20) X=20 :: C=39 R=1.95 T=61  8ms 
io=(40,320) GD=(20,20) X=22 :: C=40 R=2.00 T=60  9ms 
io=(40,320) GD=(20,20) X=26 :: C=39 R=1.95 T=56  9ms 
io=(40,320) GD=(20,20) X=30 :: C=39 R=1.95 T=57  7ms 
io=(40,320) GD=(20,20) X=34 :: C=38 R=1.90 T=51  8ms 
io=(40,320) GD=(20,20) X=38 :: C=39 R=1.95 T=53  7ms 
io=(40,320) GD=(20,20) X=42 :: C=38 R=1.90 T=57 13ms
</pre> <p>
Here too, there is no apparent relationship between the
number of colors used by <i>egcLayer</i> and the number
used to generate the graph.
<p>
One can construct different variants of the layer method,
by using different methods for constructing the layers or coloring the edges.
This variant performs reasonably well, is simple and fast.

<h3>Color Palette Method</h3>
The colors used for the edges within a group can be viewed as the
<i>palette</i> of that group.
The palettes defined by a proper $C$-coloring have the
following properties.
<ul>
<li> For each input $u$, the groups that have $u$ as their hub have
    disjoint palettes.
<li> For each output $v$, one can define a bipartite <i>palette graph</i> $P(v)$
    with edges $(g,c)$ where $g$ is a group with an edge at $v$ and $c$ is
    a color in $g$'s palette. $P(v)$ has a matching that matches all of its
    inputs. The edges in this matching can be used to color the edges at $v$.
</ul>
Kirkpatrick, Klawe and Pippenger [KKP85] identified these properties and
used them to show that any graph can be colored using at most
$$(\Gamma_i âˆ’ 1)\lfloor\log_2(2*n_o)\rfloor + 2\Delta_o$$ colors.
Specifically, they showed that for every graph with at least this many colors,
there is a valid collection of palettes for which every $P(v)$ has a
matching that includes all its inputs.
They did not show how to compute such a collection of palettes, just that
at least one such collection must exist.
<p>
[Turner15c] showed that for large enough $C$ a random collection of palettes
has the required matchings with probability $>1/2$.
The required condition is that $C \geq C^\ast = k \max(\Gamma_i, \Delta_o)$ and
$k$ is an integer that is at least
$$2 (\ln 2\Delta_o n_o/ \ln \ln 2\Delta_o n_o)^{1/2}$$
By trying multiple random palette sets, one can make the probability of finding
a valid set of palettes arbitrarily close to 1.
Note that this condition applies to any graph and the probability is dependent
only on the random palettes selected.
<p>
The <i>Javascript</i> program below uses binary search on $C$ to find
a set of palettes that has the required matchings. For a particular value
of $C$, it assigns the $C$ colors randomly to the groups at each input,
with the largest groups potentially getting one more color than the smallest.
Up to ten random sets of palettes are computed for each value of $C$.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
let eg;     // shared reference to EdgeGroups object
let egc;    // shared reference to EdgeGroupColors object

export default function egcKKP1(eg0) {
    eg = eg0;

    let Gamma_i = maxGroupCount(eg);
    let Delta_o = maxOutDegree(eg);
    let Cmin = lowerBound(Gamma_i, Delta_o);

    for (let u = 1; u <= eg.n_i; u++) eg.sortGroups(u);

    // identify viable range of values for binary search.
    let lo = Cmin; let hi = lo; let best;
    while(1) {
        egc = findRandomPalette(hi);
        if (egc) { best = egc; break; }
        lo = hi+1; hi *= 2;
    }
    // now proceed with binary search
    let C;
    while (lo < hi) {
        C = ~~((lo + hi)/2);
        egc = findRandomPalette(C);
        if (egc) { best = egc; hi = C; }
        else lo = C+1;
    }
    C = hi;
    
    return [best ..];
}

/** Construct random palettes for all groups and check for validity.
 *  @param C is the number of colors available
 *  @return an EdgeGroupColors object with edges colored using randomly
 *  generated palettes or null if no valid set of palettes was found
 */
function findRandomPalette(C) {
    let colors = randomPermutation(C);
    let limit = 10;
    let egc = new EdgeGroupColors(eg,C);
    for (let i = 1; i <= limit; i++) {
        egc.clear();
        for (let u = 1; u <= eg.n_i; u++) {
            let g = eg.firstGroupAt(u);
            for (let ci = 1; ci <= C; ci++) {
                egc.bind(colors[ci],g);
                g = eg.nextGroupAt(u,g);
                if (!g) g = eg.firstGroupAt(u);
            }
            scramble(colors);
        }
        if (egc.colorFromPalettes()) return egc;
    }
    return null;
}
</textarea><p>

Here is the trace output for an example. Note that the
palettes are shown with each group, followed by the coloring
obtained by computing matchings for all the palette graphs.
<p> <pre style="padding-left:5%">
graph with palettes {
a[(e k o p){4 2} (f g j m){1 5} (l){3}]
b[(e n o p){1 2} (m i l){3 4} (h k){5}]
c[(h k g j m){3 1} (i l n){2 4} (f){5}]
d[(e i o p){2 5} (f g h){3 4} (j n){1}]
}

colors: {
1[b(e . o p) a(f g . m) d(j n)]
2[d(e . o p) c(i l .) b(. n . .)]
3[d(f . .) c(h k g j m) b(. i .) a(l)]
4[a(e k o p) d(. g h) b(m . l) c(. . n)]
5[c(f) b(h k) d(. i . .) a(. . j .)]
}
</pre><p>

The results below show how the algorithm performs as the ratio of
outputs to inputs grows.
<p> <pre style="padding-left:5%">
io=(40,  40) GD=(20,20) X=22 :: C=31 R=1.55  39ms 
io=(40,  80) GD=(20,20) X=22 :: C=38 R=1.90  40ms 
io=(40, 160) GD=(20,20) X=22 :: C=43 R=2.15 115ms 
io=(40, 320) GD=(20,20) X=22 :: C=43 R=2.15 157ms 
io=(40, 640) GD=(20,20) X=22 :: C=45 R=2.25 334ms 
io=(40,1280) GD=(20,20) X=22 :: C=46 R=2.30 857ms 
</pre><p>
Note that for the largest examples, the random threshold implies a
requirement of five colors per group, while the number used by the
algorithm on random graphs is less than half that.
<p>
One can also compute a collection of palettes in a more systematic way.
One way to do this is to iterate through the outputs, and for each output $v$
expand the palettes of the groups containing $v$ as needed to ensure
that all the edges at $v$ can be colored.
<p>
When processing an output $v$, this algorithm first constructs the palette
graph $P(v)$ (based on colors assigned to palettes in previous iterations)
and attempts to find a matching that includes all of its inputs.
If this is not successful, it constructs a <i>palette expansion graph</i>
$X(v)$ and computes a minimum cost flow to guide the expansion of the
palettes at $v$'s neighboring inputs.
$X(v)$ has a vertex for every group with an edge at $v$
and a vertex for every color.
It also has an edge from its source to each group $g$
and an edge from each color to the sink.
In addition, there is an edge $(g,c)$ joining each group $g$ to each
color $c$ that is not used by some other group at $g$'s hub.
The cost of the edge is 0 if $c$ is already in $g$'s palette;
otherwise the cost is the current size of $g$'s palette.
All edges have a capacity 1.
<p>
The algorithm computes a minimum cost, maximum flow on $X(v)$ and
for each edge $(g,c)$ with positive flow, it adds $c$ to $g$'s palette if
it is not already in it. If some group has no outgoing edge with positive
flow, the attempt at coloring the graph fails.
The edge costs avoid adding colors to the palettes of groups that
don't need more, and preferentially expands the palettes of groups with
smaller palettes.
A <i>Javascript</i> implementation appars below. Note that like the
random version, it uses binary search to find the smallest value of $C$
for which the algorithm suceeds.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
let eg;          // shared reference to EdgeGroups object
let egc;         // shared reference to EdgeGroupColors object

let Delta_o;     // max degree of an output

export default function egcKKP2(eg0) {
    eg = eg0;

    Delta_o = maxOutDegree(eg);
    let Gamma_i = maxGroupCount(eg);
    let Cmin = lowerBound(Gamma_i, Delta_o);

    // identify viable range of values for binary search.
    let lo = Cmin; let hi = lo;
    while(1) {
        egc = new EdgeGroupColors(eg, hi);
        if (buildPalettes(hi)) break;
        lo = hi+1; hi *= 2;
    }
    // now proceed with binary search
    let C;
    while (lo < hi) {
        C = ~~((lo + hi)/2);
        if (buildPalettes(C)) hi = C;
        else lo = C+1;
    }
    C = hi;
    buildPalettes(C);
    egc.colorFromPalettes();

    return [egc ..];
}

/** Build collection of color palettes.
 *  @param C is the number of colors to use in the palettes
 *  @return true if the computed palettes are sufficient to color all
 *  the edges; the computed palettes are returned in egc.
 */
function buildPalettes(C) {
    egc.clear;

    // define a palette graph
    let pg = new Graph(eg.n_g+C, Delta_o*C);
    let io = new ListPair(eg.n_g + C);
    for (let g = 1; g <= eg.n_g; g++) io.swap(g);

    // define a palette expansion graph
    let xg = new Flograph(eg.n_g+C+2, Delta_o*C + Delta_o + C);
    xg.setSource(xg.n-1); xg.setSink(xg.n);

    egc.clear();
    
    let clist = new List(C);
    for (let v = eg.n_i+1; v <= eg.n_i + eg.n_o; v++) {
        // first, check to see if v's edges can be colored with current palettes
        let dv = eg.graph.degree(v);
        pg.clear();
        for (let e = eg.graph.firstAt(v); e; e = eg.graph.nextAt(v,e)) {
            let g = eg.group(e); let u = eg.hub(g);
            for (let c = egc.firstColor(g); c; c = egc.nextColor(g,c)) {
                pg.join(g, eg.n_g+c);
            }
        }
        let [match] = bimatchHK(pg,0,io);
        if (match.size() == dv) continue;

        // Try to expand palette's for the groups with edges at v, without
        // increasing the total number of colors.
        // Do this by solving a mincost flow problem.
        xg.clear();
        for (let e = eg.graph.firstAt(v); e; e = eg.graph.nextAt(v,e)) {
            let g = eg.group(e); let u = eg.hub(g);
            let psize = egc.paletteSize(g);
            let xe = xg.join(xg.source,g); xg.cap(xe,1);
            for (let c = 1; c <= C; c++) {
                if (egc.owner(c,u) && egc.owner(c,u) != g) continue;
                let cv = eg.n_g+c;
                xe = xg.join(g, cv); xg.cap(xe, 1);
                xg.cost(xe, egc.owner(c,u) == g ? 0 : psize);
                if (!xg.firstOut(cv)) {
                    xe = xg.join(cv,xg.sink); xg.cap(xe, 1);
                }
            }
        }
        mcflowJEK(xg);
        if (xg.totalFlow() != dv) return false;
        for (let e = xg.firstOut(xg.source); e; e = xg.nextOut(xg.source,e)) {
            let g = xg.mate(xg.source,e); let u = eg.hub(g);
            for (let xe = xg.firstOut(g); xe; xe = xg.nextOut(g,xe)) {
                let c = xg.mate(g,xe) - eg.n_g;
                if (xg.f(xe) == 1 && !egc.owner(c,u)) {
                    egc.bind(c,g);
                }
            }
        }
    }
    return true;
}
</textarea> <p>
Here is an example of the palettes and coloring produced by
this algorithm.
<p> <pre style="padding-left:5%">
graph with palletes {
a[(e k o p){4} (f g j m){3} (l){1}]
b[(e n o p){3} (h k){1} (m i l){4}]
c[(f){4} (h k g j m){1 3} (i l n){2}]
d[(e i o p){1} (f g h){2} (j n){4}]
}

colors: {
1[d(e i o p) c(. . g j m) b(h k) a(l)]
2[d(f g h) c(i l n)]
3[b(e n o p) a(f g j m) c(h k . . .)]
4[a(e k o p) c(f) b(m i l) d(j n)]
}
</pre> <p>

The results below demonstrates how it performs on random graphs.
<p> <pre style="padding-left:5%">
io=(40,  40) GD=(20,20) X=22 :: C=20 R=1.00   86ms 
io=(40,  80) GD=(20,20) X=22 :: C=26 R=1.30  656ms 
io=(40, 160) GD=(20,20) X=22 :: C=35 R=1.75 1101ms 
io=(40, 320) GD=(20,20) X=22 :: C=39 R=1.95 1491ms 
io=(40, 640) GD=(20,20) X=22 :: C=42 R=2.10 3289ms 
io=(40,1280) GD=(20,20) X=22 :: C=44 R=2.20 3590ms 
</pre> <p>
In general, this version performs better than the random palette
version, although the relative advantage gets smaller as the graphs
get larger.

<h3>Constrained Greedy Method</h3>
Yang and Masson [YM91] devised a greedy strategy for coloring
each group in turn. When assigning colors to a group, it selects
each color to maximize the number of previously uncolored edges
that can be colored. They show, that this strategy is guaranteed
to succeed if the number of colors used by each group is constrained to
be no larger than an integer $k$ and the total number of colors is at least
$$ (\Gamma_i âˆ’1)k+(\Delta_o âˆ’1) n_o^{1/k} +1 $$
The value of $k$ can be chosen to minimize the number of colors and
they show that when $\Gamma_i = \Delta_o$, the best value of $k$ is
approximately $2 \ln n_o/ \ln \ln n_o$.
<p>
The <i>Javascript</i> implementation shown below first sorts the groups
in decreasing order of size and uses binary search to find the smallest
color for which the greedy method yields a complete coloring.
It also relaxes the constraint on the number of colors used per group,
when previously colored groups leave more colors available for use.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
let eg;        // shared reference to EdgeGroups object
let egc;       // shared reference to EdgeGroupColors object

let colorCount;          // colorCount[u] is number of colors in use at u
let coloredGroupCount;   // coloredGroupCount[u] # of colored groups at u

export default function egcYM(eg0) {
    eg = eg0; eg.sortAllGroups();

    let Gamma_i = maxGroupCount(eg);
    let Delta_o = maxOutDegree(eg);
    let Cmin = lowerBound(Gamma_i, Delta_o);

    // identify viable range of values for binary search.
    let lo = Cmin; let hi = lo;
    while(1) {
        egc = new EdgeGroupColors(eg, hi);
        colorCount = new Int32Array(hi+1);
        coloredGroupCount = new Int32Array(hi+1);
        if (colorAllGroups(hi)) break;
        lo = hi+1; hi *= 2;
    }
    // now proceed with binary search
    let C;
    while (lo < hi) {
        C = ~~((lo + hi)/2);
        if (colorAllGroups(C)) hi = C;
        else lo = C+1;
    }
    C = hi;

    colorAllGroups(C);

    return [egc ..];
}

function colorAllGroups(C) {
    egc.clear(); colorCount.fill(0); coloredGroupCount.fill(0);
    for (let g = eg.firstGroup(); g; g = eg.nextGroup(g))
        if (!colorGroup(g, C)) return false;
    return true;
}

/** Assign colors to one group.
 *  @param g is group number
 *  @param C is the largest color
 *  @return true on success
 */
function colorGroup(g, C) {
    // set limit on # of colors per group
    let u = eg.hub(g);
    let limit = Math.ceil((C - colorCount[u]) /
                          (eg.groupCount(u) - coloredGroupCount[u]));
    let colored = 0; // number of edges colored so far
    let k = 0; // number of colors used so far

    while (k < limit && colored < eg.fanout(g)) {
        // first find best color for the remaining uncolored edges
        let bestColor = 0; let bestCount = 0;
        for (let c = 1; c <= C; c++) {
            let count = 0;
            for (let e = eg.firstInGroup(g); e; e = eg.nextInGroup(g,e)) {
                if (egc.color(e) == 0 && egc.avail(c,e)) count++;
            }
            if (count > bestCount) {
                bestColor = c; bestCount = count;
            }
            // stop early if c can color all remaining edges
            if (colored + bestCount == eg.fanout(g)) break;
        }
        if (!bestColor) return false;
        for (let e = eg.firstInGroup(g); e; e = eg.nextInGroup(g,e)) {
            if (egc.color(e) == 0 && egc.avail(bestColor,e)) {
                egc.color(e,bestColor); colored++;
            }
        }
        k++;
    }
    if (colored != eg.fanout(g)) return false;
    colorCount[u] += k; coloredGroupCount[u]++;
    return true;
}
</textarea> <p>
Here is the result produced on an example.
<p> <pre style="padding-left:5%">
graph with palletes {
a[(e k o p){2} (f g j m){3} (l){1}]
b[(e n o p){1} (h k){3} (m i l){2}]
c[(f){5} (h k g j m){1} (i l n){4}]
d[(e i o p){3} (f g h){2} (j n){5}]
}

colors: {
1[c(h k g j m) b(e n o p) a(l)]
2[a(e k o p) b(m i l) d(f g h)]
3[a(f g j m) d(e i o p) b(h k)]
4[c(i l n)]
5[d(j n) c(f)]
}
</pre> <p>
The results below demonstrate its performance on random graphs.
<p> <pre style="padding-left:5%">
io=(40,  40) GD=(20,20) X=22 :: C=26 R=1.30   5ms 
io=(40,  80) GD=(20,20) X=22 :: C=27 R=1.35   9ms 
io=(40, 160) GD=(20,20) X=22 :: C=30 R=1.50  12ms 
io=(40, 320) GD=(20,20) X=22 :: C=34 R=1.70  32ms 
io=(40, 640) GD=(20,20) X=22 :: C=41 R=2.05 116ms 
io=(40,1280) GD=(20,20) X=22 :: C=45 R=2.25 247ms 
</pre> <p>

<h3>Hybrid Algorithm</h3>

One can combines elements of the YM and KKP algorithms to produce
a hybrid.
For each value of $C$ considered during the binary search,
it first attempts to find a coloring using the YM
algorithm. If this fails, it attempts to expand the palettes
defined by the failed attempt, using the method from the KKP algorithm.
This approach was motivated by the observation that the YM algorithm
usually leaves many colors at each input unassigned, creating an
opportunity for improved performance.
<p>
Here is a <i>Javascript</i> implementation.
<p> <textarea rows="20" cols="80" readonly
        style="font-size: 95%;background-color:lightCyan">
let eg;        // shared reference to EdgeGroups object
let egc;       // shared reference to EdgeGroupColors object

let colorCount;          // colorCount[u] is number of colors in use at u
let coloredGroupCount;   // coloredGroupCount[u] # of colored groups at u

export default function egcT2(eg0) {
    eg = eg0; eg.sortAllGroups();

    let Gamma_i = maxGroupCount(eg);
    let Delta_o = maxOutDegree(eg);
    let Cmin = lowerBound(Gamma_i, Delta_o);

    // identify viable range of values for binary search.
    let lo = Cmin; let hi = lo;
    while(1) {
        egc = new EdgeGroupColors(eg, hi);
        colorCount = new Int32Array(hi+1);
        coloredGroupCount = new Int32Array(hi+1);
        if (colorAllGroups(hi) || expandPalettes(hi, Delta_o))
            break;
        lo = hi+1; hi *= 2;
    }
    // now proceed with binary search
    let C;
    while (lo < hi) {
        C = ~~((lo + hi)/2);
        if (colorAllGroups(C) || expandPalettes(C, Delta_o))
            hi = C;
        else
            lo = C+1;
    }
    C = hi;

    colorAllGroups(C) || expandPalettes(C, Delta_o);

    return [egc ..];
}

function colorAllGroups(C) {
    egc.clear(); colorCount.fill(0); coloredGroupCount.fill(0);
    let success = true;
    for (let g = eg.firstGroup(); g; g = eg.nextGroup(g)) {
        if (!colorGroup(g, C)) success = false;
    }
    return success;
}

/** Assign colors to one group.
 *  @param g is group number
 *  @param C is the largest color
 *  @return the number of uncolored edges
 */
function colorGroup(g, C) {
    // set limit on # of colors per group
    let u = eg.hub(g);
    let limit = Math.ceil((C - colorCount[u]) /
                          (eg.groupCount(u) - coloredGroupCount[u]));
    let colored = 0; // number of edges colored so far
    let k = 0; // number of colors used so far

    while (k < limit && colored < eg.fanout(g)) {
        // first find best color for the remaining uncolored edges
        let bestColor = 0; let bestCount = 0;
        for (let c = 1; c <= C; c++) {
            let count = 0;
            for (let e = eg.firstInGroup(g); e; e = eg.nextInGroup(g,e)) {
                if (egc.color(e) == 0 && egc.avail(c,e)) count++;
            }
            if (count > bestCount) {
                bestColor = c; bestCount = count;
            }
            // stop early if c can color all remaining edges
            if (colored + bestCount == eg.fanout(g)) break;
        }
        if (!bestColor) break;
        for (let e = eg.firstInGroup(g); e; e = eg.nextInGroup(g,e)) {
            if (egc.color(e) == 0 && egc.avail(bestColor,e)) {
                egc.color(e,bestColor); colored++;
            }
        }
        k++;
    }
    if (colored != eg.fanout(g)) return false;
    colorCount[u] += k; coloredGroupCount[u]++;
    return true;
}

function expandPalettes(C, Delta_o) {
    // define a palette graph
    let pg = new Graph(eg.n_g+C, Delta_o*C);
    let io = new ListPair(eg.n_g + C);
    for (let g = 1; g <= eg.n_g; g++) io.swap(g);

    // define a palette expansion graph
    let xg = new Flograph(eg.n_g+C+2, Delta_o*C + Delta_o + C);
    xg.setSource(xg.n-1); xg.setSink(xg.n);

    for (let v = eg.n_i+1; v <= eg.n_i + eg.n_o; v++) {
        let dv = eg.graph.degree(v);
        // first, check to see if v's edges can be colored with current palettes
        pg.clear();
        for (let e = eg.graph.firstAt(v); e; e = eg.graph.nextAt(v,e)) {
            egc.color(e,0);        // removes color but does not affect palette
            let g = eg.group(e); let u = eg.hub(g);
            for (let c = egc.firstColor(g); c; c = egc.nextColor(g,c)) {
                pg.join(g, eg.n_g+c);
            }
        }
        let [match] = bimatchHK(pg,0,io);
        if (match.size() == dv) continue;

        // Expand palette's for the groups with edges at v as needed.
        // Do this by solving a mincost flow problem.
        xg.clear(); let uncolored = 0;
        for (let e = eg.graph.firstAt(v); e; e = eg.graph.nextAt(v,e)) {
            if (!egc.color(e)) uncolored++;
            let g = eg.group(e); let u = eg.hub(g);
            let psize = egc.paletteSize(g);
            let xe = xg.join(xg.source,g); xg.cap(xe,1);
            for (let c = 1; c <= C; c++) {
                if (egc.owner(c,u) && egc.owner(c,u) != g) continue;
                let cv = eg.n_g+c;
                xe = xg.join(g, cv); xg.cap(xe, 1);
                xg.cost(xe, egc.owner(c,u) == g ? 0 : psize);
                if (!xg.firstOut(cv)) {
                    xe = xg.join(cv,xg.sink); xg.cap(xe, 1);
                }
            }
        }
        if (uncolored == 0) continue;
        mcflowJEK(xg);
        if (xg.totalFlow() != eg.graph.degree(v)) return false;
        for (let e = xg.firstOut(xg.source); e; e = xg.nextOut(xg.source,e)) {
            let g = xg.mate(xg.source,e); let u = eg.hub(g);
            for (let xe = xg.firstOut(g); xe; xe = xg.nextOut(g,xe)) {
                let c = xg.mate(g,xe) - eg.n_g;
                if (xg.f(xe) == 1 && !egc.owner(c,u)) egc.bind(c,g);
            }
        }
    }
    egc.colorFromPalettes();
    return true;
}
</textarea> <p>
The trace output for an example is shown below.
<p> <pre style="padding-left:5%">
graph with palletes {
a[(e k o p){2} (f g j m){3} (l){1}]
b[(e n o p){1} (h k){3} (m i l){2}]
c[(f){2} (h k g j m){1} (i l n){4 3}]
d[(e i o p){3} (f g h){2 1} (j n){4}]
}

colors: {
1[b(e n o p) d(f . .) c(h k g j m) a(l)]
2[a(e k o p) c(f) d(. g h) b(m i l)]
3[d(e i o p) a(f g j m) b(h k) c(. . n)]
4[c(i l .) d(j n)]
}
</pre> <p>
The results below illustrate how the new algorithm performs
on random graphs.
<p> <pre style="padding-left:5%">
io=(40,  40) GD=(20,20) X=22 :: C=20 R=1.00   83ms 
io=(40,  80) GD=(20,20) X=22 :: C=23 R=1.15  108ms 
io=(40, 160) GD=(20,20) X=22 :: C=26 R=1.30  161ms 
io=(40, 320) GD=(20,20) X=22 :: C=32 R=1.60  195ms 
io=(40, 640) GD=(20,20) X=22 :: C=37 R=1.85  390ms 
io=(40,1280) GD=(20,20) X=22 :: C=42 R=2.10 1002ms 
</pre> <p>
Here is a comparison showing all the algorithms for an
example with moderate input/output asymmetry.

<p> <pre style="padding-left:5%">
T1   io=(40,320) GD=(20,20) X=22 :: C=40 R=2.00   14ms 
KKP1 io=(40,320) GD=(20,20) X=22 :: C=44 R=2.20  247ms 
KKP2 io=(40,320) GD=(20,20) X=22 :: C=39 R=1.95 1491ms 
YM   io=(40,320) GD=(20,20) X=22 :: C=34 R=1.70   29ms 
T2   io=(40,320) GD=(20,20) X=22 :: C=32 R=1.60  189ms 
</pre> <p>

<h2>References</h2>
<dl>
<dt> [Attiya06]
<dd> &ldquo;Packet-Mode Emulation of Output-Queued Switches,&rdquo;
    by H Attiya, D. Hay and I. Keslassy.
    In <i>Proc. of ACM SPAA</i>, 2006.

<dt> [Chuang99]
<dd> &ldquo;Matching output queueing with a combined input output
    queued switch,&rdquo;
    by S.-T. Chuang, A. Goel, N. McKeown, B. Prabhakar.
    In <i>IEEE J. on Selected Areas in Communications</i>, 12/1999.

<dt> [KKP85]
<dd> &ldquo;Some Graph-Colouring Theorems with Applications to
    Generalized Connection Networks,&rdquo;
    by David Kirkpatrick, Maria Klawe and Nick Pippenger.
    In <i>SIAM Journal of Algorithms and Discrete Methods</i>, 10/1985.

<dt> [Krishna99]
<dd> &ldquo;On the speedup required for work-conserving crossbar
    switches,&rdquo;
    by P. Krishna, N. Patel, A. Charny and R. Simcoe.
    In <i>IEEE Journal on Selected Areas of Communications</i>, 6/1999.

<dt> [Leonardi01]
<dd> &ldquo;On the stability of input-queued switches with speed-up,&rdquo;
    by E. Leonardi, M. Mellia, F. Neri, and M.A. Marsan.
    In <i>IEEE/ACM Transactions on Networking</i>,
    Vol. 9, No. 1, pp. 104--118, 2/2001.

<dt> [Mckeown99a]
<dd> &ldquo;$i$SLIP: a scheduling algorithm for input-queued switches,&rdquo;
    by N. McKeown.
    In <i>IEEE Trans. on Networking</i>, 4/1999.

<dt> [Mckeown99b]
<dd> &ldquo;Achieving 100\% Throughput in an Input-Queued Switch,&rdquo;
    McKeown, N., A. Mekkittikul, V. Anantharam, and J. Walrand.
    In <i>IEEE Trans. on Communications</i>, Vol. 47, No. 8, 8/1999.

<dt> [PMA97]
<dd> &ldquo;Multicast scheduling for input-queued switches,&rdquo;
    by B. Prabhakar, N. McKeown and R. Ahuja.
    In <i>IEEE Journal on Selected Areas in Commuications</i>, 6/1997.

<dt> [YM91]
<dd> &ldquo;Nonblocking broadcast switching networks,&rdquo;
    by Yuanyan Yang and Gerald Masson.
    In <i>IEEE Transactions on Computers</i>, 9/1991.

<dt> [Turner15a]
<dd> &ldquo;Maximum priority matchings,&rdquo; by Jonathan Turner.
     Washington University Computer Science Technical Report,
     WUCSE-2015-06, 11/2015.
     Also available in Computing Research Repository (CoRR)
     arXiv:1512.08555 [cs.DS].

<dt> [Turner15b]
<dd> &ldquo;The Bounded Edge Coloring Problem and Offline Crossbar
     Scheduling,&rdquo; by Jonathan Turner.
     Washington University Computer Science Technical Report,
     WUCSE-2015-06, 11/2015.
     Also available in Computing Research Repository (CoRR)
     arXiv:1512.08555 [cs.DS].

<dt> [Turner15c]
<dd> &ldquo;The Edge Group Coloring Problem with Applications to
    Multicast Switching,&rdquo; by Jonathan Turner.
     Washington University Computer Science Technical Report,
     WUCSE-2015-02, 8/2015.
     Also available in Computing Research Repository (CoRR)
     arXiv:arXiv:1512.08995 [cs.DS].
</dl>

<hr> <h4>&copy; Jonathan Turner - 2023</h4>
<script src="../../googleAnalytics.js"></script>
</body>
</html>
